/*  This file is part of the PopART IBM.

    The PopART IBM is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    The PopART IBM is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with the PopART IBM.  If not, see <http://www.gnu.org/licenses/>.
 */


/* Output routines for PopART model:

* print_population()
    Prints the contents of a population structure
* print_population_from_one_year_data()
    Using a population_size_one_year_age struct, generates and prints number in each age group.
    Function used to output incident and prevalent cases.
* print_population_one_year()
    prints the contents of a population_size_one_year_age structure.
* print_population_one_year_only_old()
    prints the contents of a population_size_one_year_age structure.
* print_stratified_population()
    prints the contents of a population structure (ie pop size by age gp x gender, risk x gender,
    gender and overall). 
* print_individual()
    checking function which prints some key characteristics of an individual.   
* print_partners()
    for a given individual print all their partner ids (and their HIV+ partners if HIV-).
* print_partnership()
    prints the ids of people in a given partnership, and the duration of their partnership.
* print_HIV_status()
    prints the HIV status of a given individual.
* print_demographics()
    prints the % by age gp, gender, risk gp using individuals to check pop[] array contents. 
* print_number_by_age()
    using age_list, prints the number of individuals in each year age group.
* print_IDs_by_age()
* print_specific_IDs_by_age()
* print_number_by_age_grouped()
    prints the number and % of individuals in each age group 13-17, 18=23, etc.
* update_outputs_gender_veryshort()
    updates the gender-specific counters in the function store_annual_outputs() to reduce 
    repetition and make it easier to adapt what is stored.  Not currently used.  
* update_annual_outputs_gender()
    updates the gender-specific counters in the function store_annual_outputs()
* update_annual_outputs_riskgp()
    updates the riskgroup-specific counters in the function store_annual_outputs()
* update_annual_outputs_npartnersbygenderagerisk()
    Counts number of partners stratified by age, gender and risk group
* store_annual_outputs()
    stores annual data (such as incidence, prevalence, number on ART, cumulative numbers of tests
    etc.) mostly by going through the whole indiv population.
* store_annual_partnerships_outputs()
    Calculates and stores data to be written to Annual_partnerships_outputs*.csv files.  
* store_timestep_outputs()
    Calculates and stores the data to be written to the Timestep_outputs*.csv files.  
* store_calibration_outputs_dhs()
    Calculates and stores DHS-specific data to be written to Calibration_output*.csv files. 
* blank_calibration_output_file()
    Creates and empty file (with a header) of the Calibration_output*.csv files.  
* write_calibration_outputs()
    Writes the Calibration_output*.csv files to disk.  
* write_annual_outputs()
    Writes annual output string generated by store_annual_outputs() to file at the end of the run. 
* write_annual_partnerships_outputs()
    Writes Annual_partnerships_outputs*.csv files to disk.  
* write_timestep_outputs()
    Writes the Timestep_outputs*.csv files to disk.  

*** Outputs specific to the PANGEA project (related to phylogenetics) ***

* store_phylogenetic_transmission_output()
    outputs for phylogenetic model are stored in a string which will then be printed/written to
    file at the end of the simulation as this is quicker than continuously writing to file.
* store_phylogenetic_transmission_initial_cases()
    outputs for phylogenetic model for initial seeded infections.
* blank_phylo_transmission_data_file()
    Creates an empty file with a header for the phylogenetic_transmission*.csv files.  
* write_phylo_transmission_data()
    Writes phylogenetic_transmission*.csv files to disk
* write_phylo_individual_data()
    outputs key phylogenetic data for every individual ever simulated.
* write_hivpos_individual_data()
    outputs information to calculate survival of HIV+ people (and HIV+ on ART).

*** Additional functions ***

* print_partnership_network()
    Write the files Partnership_network_*.csv to disk
* print_partners_outside_community()
    Writes the files Partner_outside_inside*.csv to disk.  
* initialise_partners_outside_community_file()
* print_assortativity()
    Writes Age_assortativity_at_partnership_formation*.csv, Age_assortativity_cross_sectional*.csv,
    to disk, also Risk_assortativity_at_partnership_formation*.csv and 
    Risk_assortativity_cross_sectional*.csv files.  
* sweep_through_all_and_compute_distribution_lifetime_and_lastyear_partners()
    Called from carry_out_processes() to calculate lifetime and last-year partners before calling
    write_distr_n_lifetime_partners_and_n_partners_lastyear() to write to file.  
* write_distr_n_lifetime_partners_and_n_partners_lastyear()
    Writes the Distr_n_lifetime_partners*.csv files to disk.  
* write_pc_data()
    Calculates and writes to file data in the PC_outputs*.csv files.  
* write_chips_data_visit()
    Calculates and writes to file data within the CHIPS_outputs_visit*.csv files.  
* write_chips_data_annual()
    Calculates and writes data within the CHIPS_outputs_annual*.csv files.  
 */

/************************************************************************/
/******************************* Includes  ******************************/
/************************************************************************/

#include "output.h"
#include "structures.h"
#include "utilities.h"
#include "hiv.h"
#include "pc.h"

/************************************************************************/
/******************************** functions *****************************/
/************************************************************************/


/* This function prints the contents of a population structure */
void print_population(population_size *pop){    
    int g, ag, r;

    for(g=0 ; g<N_GENDER ; g++){
        if(g==FEMALE)
            printf("pop_size_per_age_risk_f\n");
        else if(g==MALE)
            printf("pop_size_per_age_risk_m\n");

        for(ag=0 ; ag<N_AGE ; ag++)
            for(r=0 ; r<N_RISK ; r++)
                printf("%8ld ",pop->pop_size_per_gender_age_risk[g][ag][r]);

        printf("\n");
    }

}


void print_population_from_one_year_data(population_size *pop, 
    population_size_one_year_age *pop_one_year){
    /* Calculate population based on pop_one_year and then print population
    
    Arguments
    ---------
    pop : pointer to a population_size struct
        Structure that stores a multidimensional array of population size (long) per dimensions of 
        gender, age, and risk group.  See structures.h for definition of a population_size struct.
    pop_one_year : pointer to a population_size_one_year_age struct
        Structure that stores a multidimensional array of population size (long) per dimensions of 
        gender, age, and risk group, where age is on a yearly basis, not as age groups.  See
        structures.h for definition of a population_size_one_year_age struct.
    
    Returns
    -------
    Nothing; the population is printed to stdout.  
    */

    calcul_pop_wider_age_groups(pop, pop_one_year);

    int g, ag, r;

    for(g = 0; g < N_GENDER; g++){
        if (g == FEMALE){
            printf("pop_size_per_age_risk_f\n");
        }else if (g == MALE){
            printf("pop_size_per_age_risk_m\n");
        }
        
        for(ag = 0; ag < N_AGE; ag++){
            for(r = 0; r < N_RISK; r++){
                printf("%8ld ", pop->pop_size_per_gender_age_risk[g][ag][r]);
            }
        }
        printf("\n");
    }
}


/* This function prints the contents of a population_size_one_year_age structure (ordered from age 13-79 and then age 80+). */
void print_population_one_year(population_size_one_year_age *pop){

    int g, aa, ai, r;

    for(g=0 ; g<N_GENDER ; g++)
    {
        if(g==FEMALE)
            printf("pop_size_per_age_risk_f\n");
        else if(g==MALE)
            printf("pop_size_per_age_risk_m\n");

        for (aa=0; aa<(MAX_AGE-AGE_ADULT); aa++){
            ai = pop->youngest_age_group_index + aa; /* ai is the index of the array age_list->number_per_age_group of the age group of people you want to be dead */
            while (ai>(MAX_AGE-AGE_ADULT-1))
                ai = ai - (MAX_AGE-AGE_ADULT);
            printf("age %d:\t\t",aa+AGE_ADULT);
            for(r=0 ; r<N_RISK ; r++)
                printf("%8ld ",pop->pop_size_per_gender_age1_risk[g][ai][r]);
            printf("\n");
        }
        printf("oldest age group (age 80+):\t\t");
        for(r=0 ; r<N_RISK ; r++)
            printf("%8ld ",pop->pop_size_oldest_age_group_gender_risk[g][r]);
        printf("\n");
    }

}

/* This function prints the contents of a population_size_one_year_age structure. */
void print_population_one_year_only_old(population_size_one_year_age *pop){

    int g,  r;

    for(g=0 ; g<N_GENDER ; g++)
    {
        if(g==FEMALE)
            printf("pop_size_per_age_risk_f\n");
        else if(g==MALE)
            printf("pop_size_per_age_risk_m\n");

        printf("old:\t\t");
        for(r=0 ; r<N_RISK ; r++)
            printf("%8ld ",pop->pop_size_oldest_age_group_gender_risk[g][r]);
        printf("\n");
    }

}


/* This function prints the contents of a population structure */
void print_stratified_population(stratified_population_size *pop_strat){

    int g, ag, r;

    /*printf("pop_size_per_age_risk\n");
    for(ag=0 ; ag<N_AGE ; ag++)
    {
        for(r=0 ; r<N_RISK ; r++)
        {
            printf("%8ld ",pop_strat->pop_size_per_age_risk[ag][r]);
        }
        printf("\n");
    }*/

    for(g=0; g<N_GENDER; g++)
    {
        if (g==FEMALE)
            printf("pop_size_per_age_f\n");
        else if (g==MALE)
            printf("pop_size_per_age_m\n");

        for(ag=0 ; ag<N_AGE ; ag++)
        {
            printf("%8ld ",pop_strat->pop_size_per_gender_age[g][ag]);
        }
        printf("\n");
    }

    /*printf("pop_size_per_age\n");
    for(ag=0 ; ag<N_AGE ; ag++)
    {
        printf("%8ld ",pop_strat->pop_size_per_age[ag]);
    }
    printf("\n");*/

    for(g=0; g<N_GENDER; g++)
    {
        if(g==FEMALE)
            printf("pop_size_per_risk_f\n");
        else if(g==MALE)
            printf("pop_size_per_risk_m\n");

        for(r=0 ; r<N_RISK ; r++)
            printf("%8ld ",pop_strat->pop_size_per_gender_risk[g][r]);

        printf("\n");
    }

    /*printf("pop_size_per_risk\n");
    for(r=0 ; r<N_RISK ; r++)
    {
        printf("%8ld ",pop_strat->pop_size_per_risk[r]);
    }
    printf("\n");*/

    for(g=0; g<N_GENDER; g++)
    {
        if (g==FEMALE)
            printf("prop_pop_per_risk_f\n");
        else if (g==MALE)
            printf("prop_pop_per_risk_m\n");

        for(r=0; r<N_RISK; r++)
            printf("%6.4lg ",pop_strat->prop_pop_per_gender_risk[g][r]);

        printf("\n");
    }

    printf("total_pop_size_f\n");
    printf("%8ld ",pop_strat->total_pop_size_per_gender[FEMALE]);

    printf("total_pop_size_m\n");
    printf("%8ld\n",pop_strat->total_pop_size_per_gender[MALE]);

    printf("total_pop_size\n");
    printf("%8ld\n",pop_strat->total_pop_size);
}


/* Prints some key characteristics of an individual (used  for debugging). */
void print_individual(individual *indiv)
{
    if (indiv->gender==MALE)
    {
        printf("Male, Id = %li\t DoB = %f, ",indiv->id,indiv->DoB);
        fflush(stdout);
    }
    else if (indiv->gender==FEMALE)
    {
        printf("Female, Id = %li\t DoB = %f, ",indiv->id,indiv->DoB);
        fflush(stdout);
    }

    printf("Patch = %d\t",indiv->patch_no);
    fflush(stdout);

    int n;

    printf("Number of partners = %i, ",indiv->n_partners);
    printf("among which %i are outside their patch\n\n",indiv->n_partners_outside);
    if(indiv->HIV_status==0)
    {
        printf("Number of HIV+ partners = %i,",indiv->n_HIVpos_partners);
        printf("among which %i are outside their patch\n\n",indiv->n_HIVpos_partners_outside);
    }
    fflush(stdout);

    if (indiv->n_partners>0) printf("Id of partners = ");
    for (n=0; n<indiv->n_partners; n++)
    {
        printf("%8li (patch %d), ",indiv->partner_pairs[n]->ptr[1-(indiv->gender)]->id,indiv->partner_pairs[n]->ptr[1-(indiv->gender)]->patch_no);
        fflush(stdout);
    }

    if (indiv->HIV_status==0){

        if (indiv->n_HIVpos_partners>0) printf("Id of serodiscordant partners = ");
        for (n=0; n<indiv->n_HIVpos_partners; n++)
        {
            printf("%8li (patch %d), ",indiv->partner_pairs_HIVpos[n]->ptr[1-(indiv->gender)]->id, indiv->partner_pairs_HIVpos[n]->ptr[1-(indiv->gender)]->patch_no);
            fflush(stdout);
        }
        //if (indiv->n_HIVpos_partners>0)
        printf("\nIndex in list of susceptibles in serodiscordant partnership = %li\n\n",indiv->idx_serodiscordant);
        fflush(stdout);
    }

    //partnership* partner_pairs[MAX_PARTNERSHIPS_PER_INDIVIDUAL]; /* This is a list of the partnership pairs (with someone in the community) that this individual is in at a certain time. */
    //partnership * partner_pairs_HIVpos[MAX_PARTNERSHIPS_PER_INDIVIDUAL]; /* This is a list of the partnership pairs (with someone in the community) with an HIV+ partner that this individual is in at a certain time. */


    if (indiv->HIV_status==0)
    {
        printf("HIV negative, ");
        fflush(stdout);
    }
    else if (indiv->HIV_status==1)
    {
        printf("HIV positive acute, ");
        fflush(stdout);
    }
    else if (indiv->HIV_status==2)
    {
        printf("HIV positive with CD4 = %i, SPVL category = %i,  SPVL_genetic = %6.4lf, SPVL_environmental = %6.4lf, ",indiv->cd4,indiv->SPVL_cat,indiv->SPVL_num_G,indiv->SPVL_num_E);
        fflush(stdout);
    }
    else{
        printf("Unknown HIV status\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }

    
    if (indiv->ART_status==-1)
    {
        printf("HIV negative, ");
        fflush(stdout);
    }
    else if (indiv->ART_status==0)
    {
        printf("Not On ART, ");
        fflush(stdout);
    }
    else if (indiv->ART_status>=1)
    {
        printf("HIV positive on ART with CD4 = %i, SPVL category = %i,  SPVL_genetic = %6.4lf, SPVL_environmental = %6.4lf, ",indiv->cd4,indiv->SPVL_cat,indiv->SPVL_num_G,indiv->SPVL_num_E);
        fflush(stdout);
    }
    else{
        printf("Unknown ART status\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }



    if (indiv->gender==FEMALE){
        if (indiv->time_to_delivery==-1)
        {
            printf("Not pregnant\n");
            fflush(stdout);
        }
        else
        {
            printf("Time to delivery = %i\n",indiv->time_to_delivery);
            fflush(stdout);
        }
    }
    else if (indiv->gender==MALE){
        if (indiv->circ==VMMC||indiv->circ==TRADITIONAL_MC){
            printf("Circumcised\n");
            fflush(stdout);
        }
        else
        {
            printf("Uncircumcised\n");
            fflush(stdout);
        }
    }


    if (indiv->sex_risk==LOW)
    {
        printf("Low sex risk group, Maximum number of partners = %i, Number of partners outside cluster = %i, ",indiv->max_n_partners, indiv->n_partners_outside);
        fflush(stdout);
    }
    else if (indiv->sex_risk==MEDIUM)
    {
        printf("Medium sex risk group, Maximum number of partners = %i, Number of partners outside cluster = %i, ",indiv->max_n_partners, indiv->n_partners_outside);
        fflush(stdout);
    }
    else if (indiv->sex_risk==HIGH)
    {
        printf("High sex risk group, Maximum number of partners = %i, Number of partners outside cluster = %i, ",indiv->max_n_partners, indiv->n_partners_outside);
        fflush(stdout);
    }
    else{
        printf("Unknown sex risk group\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    printf("\n");
    fflush(stdout);

}


void print_partners(individual *indiv){
   /* For a given individual, print all partner ids. 
    
    If the individual is HIV- then prints their HIV+ partners as well. Used in checks.c.  
    
    Arguments
    ---------
    indiv : a pointer to an individual struct
        The individual of interest, whose list of partners you want to print.  
    
    Returns
    -------
    Nothing; simply prints to stdout.  
    */
    
    int i;
    
    printf("Individual %ld has %d partnerships:\n", indiv->id, indiv->n_partners);
    
    for(i = 0; i < indiv->n_partners; i++){
        printf("\t with individual %ld\n", indiv->partner_pairs[i]->ptr[1-indiv->gender]->id);
    }
    
    if(indiv->HIV_status == 0){
        printf("amongst which %d partnerships with HIV positive individuals:\n",
            indiv->n_HIVpos_partners);
        
        for(i = 0; i < indiv->n_HIVpos_partners; i++){
            printf("\t with individual %ld\n",
                indiv->partner_pairs_HIVpos[i]->ptr[1-indiv->gender]->id);
        }
    }
}


/* Used in checks.c to output the two individual ids of the people in a given partnership, and the duration of their partnership. */
void print_partnership(partnership *pair)
{
    printf("Individuals %ld and %ld are in a partnership which will last for %lg years from time of formation.\n",pair->ptr[0]->id,pair->ptr[1]->id, pair->duration_in_time_steps*TIME_STEP);
}


/* Prints the HIV status of a given individual.  */
void print_HIV_status(individual *indiv){
    if(indiv->HIV_status==0)
    {
        printf("Individual %ld is HIV negative.\n",indiv->id);
    }else
    {
        if(indiv->HIV_status==1)
        {
            printf("Individual %ld is HIV positive, in acute infection\n",indiv->id);
        }else
        {
            printf("Individual %ld is HIV positive, in chronic infection with CD4 %d,  SPVL_G %6.4lf, SPVL_E %6.4lf, and SPVL category %d.\n",indiv->id, indiv->cd4, indiv->SPVL_num_G, indiv->SPVL_num_E, indiv->SPVL_cat);
        }
    }

}



/* Prints the % of M/F, % by age group, % by risk group at a given time-step. 
 * It is essentially doing the same process as print_population(), but using the individuals 
 * rather than the population count - so they can double-check each other. */
void print_demographics(individual *individual_population, population_size *pop, stratified_population_size *pop_stratified, double t){
    long n, n_m=0, n_f=0;
    int ag, r;
    long *num_risk_people, *num_age_people;
    /* Use calloc() so that these are initialized to zero. */
    num_risk_people = (long*)calloc(N_RISK, sizeof(long));
    num_age_people = (long*)calloc(N_AGE, sizeof(long));
    for (n=0; n<pop_stratified->total_pop_size; n++){
        if ((individual_population[n].gender)==MALE)
            n_m++;
        else if ((individual_population[n].gender)==FEMALE)
            n_f++;
        if ((individual_population[n].sex_risk>=LOW) && (individual_population[n].sex_risk<=HIGH))
            num_risk_people[individual_population[n].sex_risk]++;
        else{
            printf("NRISK=%d undefined.\n",individual_population[n].sex_risk);
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }
        num_age_people[get_age_group(individual_population[n].DoB,t, AGE_GROUPS, N_AGE)]++;
    }

    printf("Nm=%li\t Nf=%li\nNage = ",n_m,n_f);
    for (ag=0; ag<N_AGE; ag++)
        printf("%li ",num_age_people[ag]);
    printf("\nNrisk = ");
    for (r=0; r<N_RISK; r++)
        printf("%li ",num_risk_people[r]);
    printf("\n");


    free(num_risk_people);
    free(num_age_people);
}






/* Prints the number of individuals in each year group. */
void print_number_by_age(age_list_struct *age_list){
    int aa, ai_m, ai_f;

    /* For now we sum over genders to be consistent with when age_list was not divided by gender - but can change this in future. */
    for (aa=0;aa<(MAX_AGE-AGE_ADULT);aa++){
        ai_m = aa + age_list->age_list_by_gender[MALE]->youngest_age_group_index;
        ai_f = aa + age_list->age_list_by_gender[FEMALE]->youngest_age_group_index;
        /* Make sure never goes beyond end of array. */
        while (ai_m>(MAX_AGE-AGE_ADULT-1))
            ai_m = ai_m - (MAX_AGE-AGE_ADULT);
        while (ai_f>(MAX_AGE-AGE_ADULT-1))
            ai_f = ai_f - (MAX_AGE-AGE_ADULT);

        printf("Number aged %i = %li\n",aa+AGE_ADULT,age_list->age_list_by_gender[MALE]->number_per_age_group[ai_m]+age_list->age_list_by_gender[FEMALE]->number_per_age_group[ai_f]);
    }
    printf("Number aged %i+ = %li\n",MAX_AGE,age_list->age_list_by_gender[MALE]->number_oldest_age_group+age_list->age_list_by_gender[FEMALE]->number_oldest_age_group);
}

void print_IDs_by_age(age_list_struct *age_list){
    int aa, ai, k, g;


    printf("------------- AGE LIST -------------\n");
    fflush(stdout);

    for (aa=0;aa<(MAX_AGE-AGE_ADULT);aa++){
        for (g=0;g<N_GENDER;g++){
            ai = aa + age_list->age_list_by_gender[g]->youngest_age_group_index;
            /* Make sure never goes beyond end of array. */
            while (ai>(MAX_AGE-AGE_ADULT-1))
                ai = ai - (MAX_AGE-AGE_ADULT);
            printf("Who is aged %i = ",aa+AGE_ADULT);
            for(k=0 ; k<age_list->age_list_by_gender[g]->number_per_age_group[ai] ; k++){
                printf("%ld; ",age_list->age_list_by_gender[g]->age_group[ai][k]->id);
            }
            printf("\n");
            fflush(stdout);
        }

    }
    printf("Who is aged %i+ = \n",MAX_AGE);
    for (g=0;g<N_GENDER;g++){
        for(k=0 ; k<age_list->age_list_by_gender[g]->number_oldest_age_group ; k++){
            printf("%ld; ",age_list->age_list_by_gender[g]->oldest_age_group[k]->id);
        }
        printf("\n");
    }
    printf("--------------------------\n");
    fflush(stdout);
}

void print_specific_IDs_by_age(long id, age_list_struct *age_list, int p){
    int aa, ai, k, g;
    int res = 0;


    printf("------------- LOOK FOR %ld in patch %d IN AGE LIST -------------\n", id,p);
    fflush(stdout);

    for (g=0;g<N_GENDER;g++){
        for (aa=0;aa<(MAX_AGE-AGE_ADULT);aa++){
            ai = aa + age_list->age_list_by_gender[g]->youngest_age_group_index;
            /* Make sure never goes beyond end of array. */
            while (ai>(MAX_AGE-AGE_ADULT-1))
                ai = ai - (MAX_AGE-AGE_ADULT);
            for(k=0 ; k<age_list->age_list_by_gender[g]->number_per_age_group[ai] ; k++){
                if(age_list->age_list_by_gender[g]->age_group[ai][k]->id==id)
                {
                    printf("%ld is aged %i\n",id,aa+AGE_ADULT);
                    fflush(stdout);
                    res = 1;
                }
            }

        }
    }

    for (g=0;g<N_GENDER;g++){
        for(k=0 ; k<age_list->age_list_by_gender[g]->number_oldest_age_group ; k++){
            if(age_list->age_list_by_gender[g]->oldest_age_group[k]->id==id)
            {
                printf("%ld is aged %i\n",id,MAX_AGE);
                fflush(stdout);
                res = 1;
            }
        }
    }
    if(res==0)
        printf("!!!!!!!! %ld in patch %d was not found in age_list !!!!!!!!\n",id,p);
    printf("--------------------------\n");
    fflush(stdout);
}



/* Prints the number and % of individuals in each age group 13-17, 18=23, etc. */
void print_number_by_age_grouped(age_list_struct *age_list,population_size *n_population, stratified_population_size *n_population_stratified){
    int ag, ai, aa, g;
    long npeople[N_AGE];

    for (ag=0;ag<N_AGE;ag++)
        npeople[ag] = 0;

    for (g=0;g<N_GENDER;g++){
        for (aa=13;aa<(MAX_AGE-AGE_ADULT);aa++){
            ai = aa + age_list->age_list_by_gender[g]->youngest_age_group_index;
            /* Make sure never goes beyond end of array. */
            while (ai>(MAX_AGE-AGE_ADULT-1))
                ai = ai - (MAX_AGE-AGE_ADULT);
            npeople[FIND_AGE_GROUPS[aa]] += age_list->age_list_by_gender[g]->number_per_age_group[ai];

        }
        npeople[N_AGE-1] += age_list->age_list_by_gender[g]->number_oldest_age_group;
    }

    for (ag=0;ag<N_AGE-1;ag++)
        printf("Number in age group %i-%i = %li, percentage = %f\n",AGE_GROUPS[ag],AGE_GROUPS[ag+1]-1,npeople[ag],npeople[ag]/(1.0*n_population_stratified->total_pop_size));

    printf("Number in age group %i+ = %li, percentage = %f\n",AGE_GROUPS[N_AGE-1],npeople[N_AGE-1],npeople[N_AGE-1]/(1.0*n_population_stratified->total_pop_size));

}



/* This function updates the gender-specific counters in the function store_annual_outputs() to reduce repetition and make it easier to adapt what is stored. */
/* Not currently used. */
void update_outputs_gender_veryshort(individual *individual, long *npop_g, long *npositive, long *Nknowpositive, long *NArt, long *NVS, long *Nunknown){
    *npop_g += 1;
    if (individual->HIV_status>0){
        (*npositive) += 1;
        if ((individual->ART_status==ARTNAIVE) || (individual->ART_status==EARLYART) || (individual->ART_status==LTART_VS) || (individual->ART_status==LTART_VU) || (individual->ART_status==ARTDROPOUT) || (individual->ART_status==CASCADEDROPOUT))
            (*Nknowpositive) += 1;
        else if (individual->ART_status==ARTNEG)
            (*Nunknown) += 1;
        else{
            printf("Unknown ART status %i for individual %li\n",individual->ART_status,individual->id);
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }

        if (individual->ART_status==LTART_VS){
            (*NArt) += 1;
            (*NVS) += 1;
        }
        else if ((individual->ART_status==EARLYART) || (individual->ART_status==LTART_VU))
            (*NArt) += 1;
    }
}


void update_annual_outputs_gender(individual *individual, long *npop_g, long *npositive, 
    long *NNeedART, long *NArt, int current_cd4_guidelines){
    /* Update counters of total number of HIV+, on ART, for a given individual.  
    
    
    The counters are typically gender-specific and this function is called from the function
    store_annual_outputs() to avoid repetition.  
    
    Arguments
    ---------
    individual : pointer to an individual structure
        The individual in question who needs their status counted.  
    npop_g : pointer to a long
        Current count of population size.  
    npositive : pointer to a long
        Current count of individuals who are HIV positive.  
    NNeedART : pointer to a long
        Current counter of individuals who are eligible for ART.  
    NArt : pointer to a long
        Current count of individuals on ART.  
    current_cd4_guidelines : int
        The highest CD4 category that is eligible for ART.  See function art_cd4_eligibility_group()
        within hiv.c for details of how this variable is generated.  
    
    Returns
    -------
    Nothing; the input arguments npop_g, npositive, NNeedART, NArt are updated.  
    
    */
    
    *npop_g += 1;
    
    if(individual->HIV_status > 0){
        
        (*npositive) += 1;
        
        if(individual->cd4 >= current_cd4_guidelines){
            (*NNeedART) += 1;
        }
        
        if(
        (individual->ART_status == EARLYART) || 
        (individual->ART_status == LTART_VS) || 
        (individual->ART_status == LTART_VU)
        ){
            (*NArt) += 1;
        }
    }
}


/* This function updates the gender-specific counters in the function store_annual_outputs() to reduce repetition and make it easier to adapt what is stored. 
 * Could also store: some measure of assortativity. */
void update_annual_outputs_riskgp(individual *individual, long *npop_r, long *npositive_r, long *n_curr_part_r, long *n_curr_part_r_outside, long *n_curr_sd_part_r, long *n_curr_sd_part_r_outside, long *n_partners_thisyear_r, long *n_partners_thisyear_r_outside, long *n_lifetime_partners_r, long *n_lifetime_partners_r_outside){
    int i_risk = individual->sex_risk; 

    npop_r[i_risk] += 1;
    if (individual->HIV_status>0){
        (npositive_r[i_risk]) += 1;
    }

    else{
        /* n_HIVpos_partners is only updated for HIV- people. We want to count sd partnerships so this is OK. */
        n_curr_sd_part_r[i_risk] += individual->n_HIVpos_partners;
        n_curr_sd_part_r_outside[i_risk] += individual->n_HIVpos_partners_outside;
    }

    /* Note that n_curr_part counts each partnership TWICE (once for each partner) so need to divide by 2. */
    n_curr_part_r[i_risk] += individual->n_partners;
    n_curr_part_r_outside[i_risk] += individual->n_partners_outside;

    /* Add the number of partners that this individual has had this year to the total annual number of partners: */
    n_partners_thisyear_r[i_risk] += (individual->n_lifetime_partners - individual->n_lifetimeminusoneyear_partners);   
    n_lifetime_partners_r[i_risk] += individual->n_lifetime_partners;

    n_partners_thisyear_r_outside[i_risk] += (individual->n_lifetime_partners_outside - individual->n_lifetimeminusoneyear_partners_outside);
    n_lifetime_partners_r_outside[i_risk] += individual->n_lifetime_partners_outside;

    /* Now update the lifetimemunusoneyear partners - this will not be used again until next year (ie when store_annual_outputs() is called again). */
    individual->n_lifetimeminusoneyear_partners = individual->n_lifetime_partners;
    individual->n_lifetimeminusoneyear_partners_outside = individual->n_lifetime_partners_outside;

    individual->n_partnersminusoneyear = individual->n_partners;
}


void update_annual_outputs_npartnersbygenderagerisk(individual *individual, long n_lifetime_partners_g_r_a[N_GENDER][N_RISK][N_AGE+1], long n_lifetime_partners_g_r_a_outside[N_GENDER][N_RISK][N_AGE+1], long n_curr_part_g_r_a[N_GENDER][N_RISK][N_AGE+1], long n_curr_part_g_r_a_outside[N_GENDER][N_RISK][N_AGE+1], long n_partners_thisyear_g_r_a[N_GENDER][N_RISK][N_AGE+1], long n_partners_thisyear_g_r_a_outside[N_GENDER][N_RISK][N_AGE+1], long npop_g_r_a[N_GENDER][N_RISK][N_AGE+1], int youngest_age_index, double t){
    int i_risk = individual->sex_risk;
    int i_gender = individual->gender;
    int aa = (int) floor(floor(t) - individual->DoB) - AGE_ADULT;
    int i_age;
    if (aa>=(MAX_AGE-AGE_ADULT))
        i_age = N_AGE;
    else if ((aa>=0) && (aa<MAX_AGE-AGE_ADULT))
        i_age = FIND_AGE_GROUPS[aa];
    else{
        printf("ERROR: Unknown age in update_annual_outputs_npartnersbygenderagerisk(). Exiting\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    //printf("i_age = %i, age = %f\n",i_age,t-individual->DoB);
    npop_g_r_a[i_gender][i_risk][i_age] += 1;
    /* Note that n_curr_part counts each partnership TWICE (once for each partner) so need to divide by 2. */
    n_curr_part_g_r_a[i_gender][i_risk][i_age] += individual->n_partners;
    n_curr_part_g_r_a_outside[i_gender][i_risk][i_age] += individual->n_partners_outside;

    /* Add the number of partners that this individual has had this year to the total annual number of partners: */
    n_partners_thisyear_g_r_a[i_gender][i_risk][i_age] += (individual->n_lifetime_partners - individual->n_lifetimeminusoneyear_partners);
    n_lifetime_partners_g_r_a[i_gender][i_risk][i_age] += individual->n_lifetime_partners;

    n_partners_thisyear_g_r_a_outside[i_gender][i_risk][i_age] += (individual->n_lifetime_partners_outside - individual->n_lifetimeminusoneyear_partners_outside);
    n_lifetime_partners_g_r_a_outside[i_gender][i_risk][i_age] += individual->n_lifetime_partners_outside;

}


void store_annual_outputs(patch_struct *patch, int p, output_struct *output, 
    all_partnerships *overall_partnerships, int *n_infected_total, int year, int PCdata){
    /* Stores annual data (such as incidence, prevalence, number on ART, cum. no. of tests etc.)
    for a single patch (patch `p`) in the output structure `output`.  
    
    This function populates a range of string variables (e.g. `temp_string`) with output summaries
    from the different patches.  These strings are then added to the structure `output` which 
    is used within functions which write to file.  Output is only generated for a single year.  
    
    
    """ Previous blurb
    This is a rubbish function just set up to calibrate Pangea quickly. 
    There was previously a bug in n_infected so that it did not give the number of prevalent
    people! (due to how they were aged each year). Bug now fixed (Dec 2014).
    So I force a count by looping over all individuals.  Note that n_infected_total is the total
    current number of HIV+ people - we use it to screen out runs where prevalence drops to 0. 
    """
    
    Arguments
    ---------
    patch : pointer to an array of patch_struct structs
        An array of patch structs each of which stores information about a patch (see structures.h
        for attributes of the patch structures).  
    p : int
        The index of the patch for which output is to be generated.  
    output : pointer to an output_struct struct
        Structure within which the strings of output are to be stored.  
    overall_partnerships : pointer to an all_partnerships struct
        
    n_infected_total : pointer to an int
    year : int
        Year in question for which output is to be generated.  
    PCdata : int
        Indicator of whether this is for PCdata or not.  
    
    Returns
    -------
    Nothing; output is stored in output_struct
    */
    
    int aa, a, g, r, ai;
    long n_id;
    long npositive_wrong=0;
    long nincident=0;
    long npop_m = 0;
    long npop_f = 0;
    long npop;
    long npop_check = 0;
    long npositive_m=0;
    long npositive_f=0;
    long npositive;
    long npositive_dead = 0;
    long n_dead = 0;
    long NArt_m = 0;
    long NNeedART_m = 0;
    long NArt_f = 0;
    long NNeedART_f = 0;/* Counts no. of eligible M/F for ART given current CD4 elig criteria. */
    long NTestedLastYear = 0;
    long N_men_MC = 0;
    long naware_tot =0;
    long nvirallysuppressed_tot=0;
    long nfemale_aware=0;
    long nmale_aware=0;
    long nmale_virallysuppressed=0;
    long nfemale_virallysuppressed=0;

    long n_drug_resistant = 0;
    long n_drug_resistant_VU = 0; // count only viremic who are ART experienced(failed treatment)
    long n_ART_experienced = 0;
    long n_init_treatment_fail = 0;
    long n_init_treatment_success = 0;
    /* FOR DEBUGGING ONLY */
    long N_men_noMC = 0;
    long N_men_waitingVMMC = 0;
    long N_men_VMMC = 0;
    long N_men_VMMC_healing = 0;
    long N_men_TMC = 0;
    /************************/
    
    long N_NEW_INFECTIONS = patch[p].DEBUG_NHIVPOS-patch[p].DEBUG_NHIVPOSLASTYR;
    long npop_r[N_RISK] = {0,0,0};
    long npos_r[N_RISK] = {0,0,0};
    int current_cd4_guidelines = art_cd4_eligibility_group(patch[p].param,(double) year);

    double prop_annual_acute;
    double prop_aware=0;
    double prophivposonart=0;
    double propvirallysuppressed=0;

    /* Temporary store of data from current year. */
    char temp_string[10000];
    /* Temporary store for single variable which gets strcat'd into temp_string. */
    char temp_string2[50];
    /* Temporary store for pop size/incidence/prevalence/art/virallysuppressed by gender and age gp which gets strcat'd
    into temp_string. */
    char temp_string3[1000];
    char temp_string4[1000];
    char temp_string5[1000];
    char temp_string6[1000];
    char temp_string7[1000];
    
    int MINAGE_COUNTED, MAX_AGE_COUNTED;

    if ((PCdata != 0) && (PCdata != 1)){
        printf("ERROR:PCdata variable in store_annual_outputs() taking unknown value %i.", PCdata);
        printf("Exiting\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    if (PCdata == 0){
        MINAGE_COUNTED = 0;
        MAX_AGE_COUNTED = MAX_AGE-AGE_ADULT;
    }else{
        MINAGE_COUNTED = 18 - AGE_ADULT;
        MAX_AGE_COUNTED = 45 - AGE_ADULT;
    }

    for(g = 0; g < N_GENDER; g++){
        for(aa = MINAGE_COUNTED; aa < MAX_AGE_COUNTED; aa++){
            ai = aa + patch[p].age_list->age_list_by_gender[g]->youngest_age_group_index;
            while (ai>(MAX_AGE-AGE_ADULT-1)){
                ai = ai - (MAX_AGE-AGE_ADULT);
            }
            npop_check += patch[p].age_list->age_list_by_gender[g]->number_per_age_group[ai];
        }
        npop_check += patch[p].age_list->age_list_by_gender[g]->number_oldest_age_group;
    }

    for(g = 0; g < N_GENDER; g++){
        for(r = 0; r < N_RISK; r++){
            for(aa = MINAGE_COUNTED; aa < MAX_AGE_COUNTED; aa++){
                ai = aa + patch[p].n_infected->youngest_age_group_index;
                while(ai > (MAX_AGE - AGE_ADULT - 1)){
                    ai = ai - (MAX_AGE - AGE_ADULT);
                }
                
                /* NOTE: if we are getting prevalence by age group we have to offset the aa by
                n_infected->youngest_age_group_index. */
                npositive_wrong += patch[p].n_infected->pop_size_per_gender_age1_risk[g][ai][r];

                ai = aa + patch[p].n_newly_infected->youngest_age_group_index;
                while (ai > (MAX_AGE - AGE_ADULT - 1)){
                    ai = ai - (MAX_AGE - AGE_ADULT);
                }
                nincident += patch[p].n_newly_infected->pop_size_per_gender_age1_risk[g][ai][r];
            }
            /* Only count if we are counting the whole population, not just PC age groups. */
            if (PCdata == 0){
                npositive_wrong += patch[p].n_infected->pop_size_oldest_age_group_gender_risk[g][r];
                nincident += patch[p].n_newly_infected->pop_size_oldest_age_group_gender_risk[g][r];
            }
        }
    }

    /* This if statement determines if we are just looking at PC stuff: */
    //if (PCdata==0){
    for (n_id = 0; n_id < patch[p].id_counter; n_id++){
        /* Check that the person is not dead: */
        if (patch[p].individual_population[n_id].cd4!=DEAD){
            /* Count number of peole currently alive who had an HIV test in the past year. */
            if ((year - patch[p].individual_population[n_id].time_last_hiv_test) <= 1.0){
                NTestedLastYear++;
            }
            /* Count total drug resistant*/
            if (patch[p].individual_population[n_id].drug_resistant == 1){
              n_drug_resistant++; 
              if (patch[p].individual_population[n_id].ART_status != LTART_VS){
                n_drug_resistant_VU++;
              }
            }
            /* count ART experienced*/
            if (patch[p].individual_population[n_id].ART_status >= EARLYART && patch[p].individual_population[n_id].ART_status < CASCADEDROPOUT){
                n_ART_experienced++;
            }
            /* count those who initially failed treatment in the last year */
            if(((year - patch[p].individual_population[n_id].last_start_art) <= 1.0 && (year - patch[p].individual_population[n_id].last_start_art) >=0) && patch[p].individual_population[n_id].init_treatment_outcome == TREATMENT_INITFAIL){
                n_init_treatment_fail++;
            }//PANGEA_date_firstARTstart
            /* count those who initially suppressed post treatment in the last year */
            if(((year - patch[p].individual_population[n_id].last_start_art) <= 1.0 && (year - patch[p].individual_population[n_id].last_start_art) >=0) && patch[p].individual_population[n_id].init_treatment_outcome == TREATMENT_INITSUCCESS){
                n_init_treatment_success++;
            }
            /* Gender-specific outputs derived here: */
            if (patch[p].individual_population[n_id].gender == MALE){
                /* Use a function here so easy to add extra stratifications to output: */
                update_annual_outputs_gender(&(patch[p].individual_population[n_id]), &npop_m,
                    &npositive_m, &NNeedART_m, &NArt_m, current_cd4_guidelines);
                
                /* Count number of men who are currently circ: */
                if(
                (patch[p].individual_population[n_id].circ == VMMC) ||
                (patch[p].individual_population[n_id].circ == VMMC_HEALING) || 
                (patch[p].individual_population[n_id].circ == TRADITIONAL_MC)
                ){
                    N_men_MC++;
                }
                if(patch[p].individual_population[n_id].HIV_status > UNINFECTED){                
                    if(patch[p].individual_population[n_id].ART_status >= ARTNAIVE && 
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
 
                            nmale_aware+=1;
                            
                            naware_tot+=1;
                        }
                 if(patch[p].individual_population[n_id].ART_status == 2 && 
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
 
                            nmale_virallysuppressed +=1;
                            
                            nvirallysuppressed_tot+=1;
                        }
                }
                /* Count number of men who are in different circ groups*/
                if (patch[p].individual_population[n_id].circ == UNCIRC)
                    N_men_noMC++;
                else if(patch[p].individual_population[n_id].circ == UNCIRC_WAITING_VMMC)
                    N_men_waitingVMMC++;
                else if(patch[p].individual_population[n_id].circ == VMMC)
                    N_men_VMMC++;
                else if(patch[p].individual_population[n_id].circ == VMMC_HEALING)
                    N_men_VMMC_healing++;
                else if(patch[p].individual_population[n_id].circ == TRADITIONAL_MC)
                    N_men_TMC++;
                else{
                    printf("ERROR: Unknown circumcision status");
                    printf("%i ", patch[p].individual_population[n_id].circ);
                    printf("for individual %li in patch %i. Exiting\n", n_id, p);
                    printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
                    fflush(stdout);
                    exit(1);
                }
            }else{ /* Else female */            
                update_annual_outputs_gender(&(patch[p].individual_population[n_id]), &npop_f,
                    &npositive_f, &NNeedART_f, &NArt_f, current_cd4_guidelines);
                if(patch[p].individual_population[n_id].HIV_status > UNINFECTED){                
                    if(patch[p].individual_population[n_id].ART_status >= ARTNAIVE && 
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
                            nfemale_aware+=1;
                            
                            naware_tot+=1;
                        }
                    if(patch[p].individual_population[n_id].ART_status == 2 && 
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
 
                            nfemale_virallysuppressed +=1;
                            
                            nvirallysuppressed_tot+=1;
                        }
                }


            }
            
            /* RiskGroup-specific outputs derived here: */
            npop_r[(patch[p].individual_population[n_id]).sex_risk] += 1;
            
            if ((patch[p].individual_population[n_id]).HIV_status > 0){
                (npos_r[(patch[p].individual_population[n_id]).sex_risk]) += 1;
            }
        }else{
            n_dead += 1;
            if (patch[p].individual_population[n_id].HIV_status > 0){
                npositive_dead += 1;
            }
        }
    }

    npop = npop_m + npop_f;
    npositive = npositive_m + npositive_f;
    
    /* Store number of positive people in n_infected_total: */
    *n_infected_total = npositive;

    if (patch[p].PANGEA_N_ANNUALINFECTIONS > 0){
        
        prop_annual_acute = patch[p].PANGEA_N_ANNUALACUTEINFECTIONS/
            (1.0*patch[p].PANGEA_N_ANNUALINFECTIONS);
        
    }else{
        prop_annual_acute = 0.0;
    }
    
    if (npositive > 0){
        prophivposonart = (NArt_m + NArt_f)/(1.0*npositive);
        prop_aware = (1.0*naware_tot)/npositive;
        if (NArt_m + NArt_f >0) {
            propvirallysuppressed=(1.0*nvirallysuppressed_tot)/(NArt_m + NArt_f);
        }
        else{
            propvirallysuppressed=0;
        }
    }else{
        prophivposonart = 0.0;
        prop_aware=0.0;
        propvirallysuppressed=0.0;
    }

    if(PCdata == 0){
        
        sprintf(temp_string, "%i,%8.6f,%8.6f,%8.6f,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%8.6f,%8.6f,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%6.4f,%li,%li,%li,%li,",
                year,
                npositive/(npop+0.0),
                prop_aware,
                patch[p].PANGEA_N_ANNUALINFECTIONS/(npop - npositive + 0.0),
                npositive,
                n_drug_resistant,
                n_drug_resistant_VU,
                n_ART_experienced,
                n_init_treatment_fail,
                n_init_treatment_success,
                patch[p].n_newly_infected_total,
                patch[p].n_newly_infected_total_from_outside,
                patch[p].n_newly_infected_total_from_acute,
                patch[p].n_newly_infected_total_from_drug_resistant,
                patch[p].n_newly_infected_total_from_drug_resistant_VU,
                prophivposonart,
                propvirallysuppressed,
                patch[p].PANGEA_N_ANNUALINFECTIONS,
                npop,
                npositive_m,
                nmale_aware,
                npop_m,
                npositive_f,
                nfemale_aware,
                npop_f,
                patch[p].cumulative_outputs->N_total_HIV_tests_nonpopart,
                patch[p].cumulative_outputs->N_total_HIV_tests_popart,
                patch[p].cumulative_outputs->N_total_CD4_tests_nonpopart,
                patch[p].cumulative_outputs->N_total_CD4_tests_popart,
                NTestedLastYear,
                NArt_m,
                nmale_virallysuppressed,
                NNeedART_m,
                NArt_f,
                nfemale_virallysuppressed,
                NNeedART_f,
                N_men_MC/(1.0*npop_m),
                *overall_partnerships->n_susceptible_in_serodiscordant_partnership,
                patch[p].OUTPUT_NDIEDFROMHIV,
                npositive_dead,
                n_dead);
                
    }else if(PCdata == 1){
        sprintf(temp_string,"%i,%8.6f,%8.6f,%8.6f,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%8.6f,%8.6f,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%6.4f,%li,%li,%li,%li,",
                year,
                npositive/(npop+0.0),
                patch[p].PANGEA_N_ANNUALINFECTIONS/(npop - npositive + 0.0),
                 (1.0*naware_tot)/npositive,
                npositive,
                n_drug_resistant,
                n_drug_resistant_VU,
                n_ART_experienced,
                n_init_treatment_fail,
                n_init_treatment_success,
                patch[p].n_newly_infected_total_pconly,
                patch[p].n_newly_infected_total_from_outside_pconly,
                patch[p].n_newly_infected_total_from_acute_pconly,
                patch[p].n_newly_infected_total_from_drug_resistant_pconly,
                patch[p].n_newly_infected_total_from_drug_resistant_VU_pconly, 
                prophivposonart,
                propvirallysuppressed,
                patch[p].PANGEA_N_ANNUALINFECTIONS,
                npop,
                npositive_m,
                nmale_aware,
                npop_m,
                npositive_f,
                nfemale_aware,
                npop_f,
                patch[p].cumulative_outputs->N_total_HIV_tests_nonpopart,
                patch[p].cumulative_outputs->N_total_HIV_tests_popart,
                patch[p].cumulative_outputs->N_total_CD4_tests_nonpopart,
                patch[p].cumulative_outputs->N_total_CD4_tests_popart,
                NTestedLastYear,
                NArt_m,
                nmale_virallysuppressed,
                NNeedART_m,
                NArt_f,
                nfemale_virallysuppressed,
                NNeedART_f,
                N_men_MC/(1.0*npop_m),
                *overall_partnerships->n_susceptible_in_serodiscordant_partnership,
                patch[p].OUTPUT_NDIEDFROMHIV,npositive_dead,n_dead);
    }
    
    
    /* I can't think of a neat way to do this but I would like each outcome for all risk groups
    together in the output file, so wrote this bit of ugly code (could make a function/macro). */
    
    for (r = 0; r < N_RISK; r++){
        sprintf(temp_string2,"%6.4f,", npop_r[r]/(1.0*npop));
        join_strings_with_check(temp_string, temp_string2, 10000, 
            "temp_string and temp_string2 in store_annual_outputs()");
    }
    for(r = 0; r < N_RISK; r++){
        sprintf(temp_string2, "%6.4f,", npos_r[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 10000,
            "temp_string and temp_string2 in store_annual_outputs()");
    }
    
    for(r = 0; r < N_RISK; r++){
        sprintf(temp_string2, "%li,", patch[p].n_newly_infected_total_by_risk[r]);
        join_strings_with_check(temp_string, temp_string2, 10000,
            "temp_string and temp_string2 in store_annual_outputs()");
    }
    
    for(r = 0; r < N_RISK; r++){
        sprintf(temp_string2, "%li,", patch[p].n_died_from_HIV_by_risk[r]);
        join_strings_with_check(temp_string, temp_string2, 10000,
            "temp_string and temp_string2 in store_annual_outputs()");
    }
    
    /* Population size and number of HIV+ and incident HIV+ by age and gender here: */
    int tempcount_pop, tempcount_inc, tempcount_prev, tempcount_art, tempcount_vs;
    
    /* Make sure these are blank: */
    memset(temp_string3, '\0', sizeof(temp_string3));
    memset(temp_string4, '\0', sizeof(temp_string4));
    memset(temp_string5, '\0', sizeof(temp_string5));
    memset(temp_string6, '\0', sizeof(temp_string5));
    memset(temp_string7, '\0', sizeof(temp_string5));
    
    /* Only store these if outputting everything for all age groups. */
    if(PCdata == 0){
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < N_AGE; a++){
                tempcount_pop = 0;
                tempcount_inc = 0;
                tempcount_prev = 0;
                tempcount_art = 0;
                tempcount_vs =0;
                for(aa = (AGE_GROUPS_WITH_OLD[a]-AGE_ADULT); 
                    aa < (AGE_GROUPS_WITH_OLD[a+1] - AGE_ADULT); 
                    aa++){
                    for(r = 0; r < N_RISK; r++){
                        ai = aa + patch[p].n_population_oneyearagegroups->youngest_age_group_index;
                        while(ai > (MAX_AGE-AGE_ADULT-1)){
                            ai = ai - (MAX_AGE-AGE_ADULT);
                        }
                        tempcount_pop += patch[p].n_population_oneyearagegroups->pop_size_per_gender_age1_risk[g][ai][r];

                        ai = aa + patch[p].n_newly_infected->youngest_age_group_index;
                        while (ai>(MAX_AGE-AGE_ADULT-1)){
                            ai = ai - (MAX_AGE-AGE_ADULT);
                        }
                        tempcount_inc += patch[p].n_newly_infected->pop_size_per_gender_age1_risk[g][ai][r];

                        ai = aa + patch[p].n_infected->youngest_age_group_index;
                        while (ai > (MAX_AGE-AGE_ADULT-1)){
                            ai = ai - (MAX_AGE-AGE_ADULT);
                        }
                        tempcount_prev += patch[p].n_infected->pop_size_per_gender_age1_risk[g][ai][r];

                        ai = aa + patch[p].n_art->youngest_age_group_index;
                        while (ai > (MAX_AGE-AGE_ADULT-1)){
                            ai = ai - (MAX_AGE-AGE_ADULT);
                        }
                        tempcount_art  += patch[p].n_art->pop_size_per_gender_age1_risk[g][ai][r];
                        
                        ai = aa + patch[p].n_virallysuppressed->youngest_age_group_index;
                        while (ai > (MAX_AGE-AGE_ADULT-1)){
                            ai = ai - (MAX_AGE-AGE_ADULT);
                        }
                        tempcount_vs   += patch[p].n_virallysuppressed->pop_size_per_gender_age1_risk[g][ai][r];
                    }
                }
                if(a == N_AGE - 1){
                    for (r = 0; r < N_RISK; r++){
                        tempcount_pop += patch[p].n_population_oneyearagegroups->pop_size_oldest_age_group_gender_risk[g][r];
                        tempcount_inc += patch[p].n_newly_infected->pop_size_oldest_age_group_gender_risk[g][r];
                        tempcount_prev += patch[p].n_infected->pop_size_oldest_age_group_gender_risk[g][r];
                        tempcount_art  += patch[p].n_art->pop_size_oldest_age_group_gender_risk[g][r];
                        tempcount_vs   += patch[p].n_virallysuppressed->pop_size_oldest_age_group_gender_risk[g][r];
                    }
                }
                sprintf(temp_string2,"%d,",tempcount_pop);
                join_strings_with_check(temp_string3, temp_string2, 1000, 
                    "temp_string3 and temp_string2 in store_annual_outputs()");

                sprintf(temp_string2,"%d,",tempcount_inc);
                join_strings_with_check(temp_string4, temp_string2, 1000, 
                    "temp_string4 and temp_string2 in store_annual_outputs()");

                sprintf(temp_string2,"%d,",tempcount_prev);
                join_strings_with_check(temp_string5, temp_string2, 1000, 
                    "temp_string5 and temp_string2 in store_annual_outputs()");

                sprintf(temp_string2,"%d,",tempcount_art);
                join_strings_with_check(temp_string6, temp_string2, 1000, 
                    "temp_string6 and temp_string2 in store_annual_outputs()");

                sprintf(temp_string2,"%d,",tempcount_vs);
                join_strings_with_check(temp_string7, temp_string2, 1000, 
                    "temp_string7 and temp_string2 in store_annual_outputs()");                                    
            }
        }
        join_strings_with_check(temp_string, temp_string3, 10000, 
            "temp_string and temp_string3 in store_annual_outputs()");
        join_strings_with_check(temp_string, temp_string4, 10000, 
            "temp_string and temp_string4 in store_annual_outputs()");
        join_strings_with_check(temp_string, temp_string5, 10000, 
            "temp_string and temp_string5 in store_annual_outputs()");
        join_strings_with_check(temp_string, temp_string6, 10000, 
            "temp_string and temp_string6 in store_annual_outputs()");
        join_strings_with_check(temp_string, temp_string7, 10000, 
            "temp_string and temp_string7 in store_annual_outputs()");                        
    }

    strcat(temp_string,"\n");
    
    /* Add the string `temp_string` to the `output` structure (so as to be written to file)*/
    if(PCdata == 1){
        
        join_strings_with_check(output->annual_outputs_string_pconly[p], 
            temp_string, SIZEOF_annual_outputs_string_pconly, 
            "output->annual_outputs_string_pconly[p] and temp_string in store_annual_outputs()");
    }else{
        
        join_strings_with_check(output->annual_outputs_string[p], 
            temp_string, SIZEOF_annual_outputs_string, 
            "output->annual_outputs_string[p] and temp_string in store_annual_outputs()");
    }
    
    
    /* These printf statement is not really needed any more, but keeping it for now as a simple way
    to compare outputs to make sure nothing has changed when running the model. */
    if (VERBOSE_OUTPUT == 1){
        printf("Prev= %6.4f Inc= %6.4f Pop_size= %li ", 
            npositive/(npop+0.0), N_NEW_INFECTIONS/(npop-npositive+0.0), npop);
        
        printf("Npos= %li Nposdead= %li Ninc= %li",npositive, npositive_dead, N_NEW_INFECTIONS);
        
        printf("Npos_AC = %li Ninc_AC = %li\n", npositive_wrong, nincident);
    }
}


void store_annual_partnerships_outputs(patch_struct *patch, int p, output_struct *output,
    all_partnerships *overall_partnerships, int *n_infected_total, int year, int PCdata){
    /*
    
    Arguments
    ---------
    patch : pointer to a patch_struct struct
    p : int
    output : pointer to an output_struct struct
    overall_partnerships : pointer to an all_partnerships struct
    n_infected_total : pointer to an int
    year : int
    PCdata : int
    
    Returns
    -------
    Nothing; stores data
    */
        
    int a, g, r;
    long n_id;
    
    long npop_r[N_RISK] = {0,0,0};
    long npos_r[N_RISK] = {0,0,0};
    long npop_g_r_a[N_GENDER][N_RISK][N_AGE+1];
    long n_lifetime_partners_g_r_a[N_GENDER][N_RISK][N_AGE+1];
    long n_curr_part_g_r_a[N_GENDER][N_RISK][N_AGE+1];
    long n_partners_thisyear_g_r_a[N_GENDER][N_RISK][N_AGE+1];
    long n_lifetime_partners_g_r_a_outside[N_GENDER][N_RISK][N_AGE+1];
    long n_curr_part_g_r_a_outside[N_GENDER][N_RISK][N_AGE+1];
    long n_partners_thisyear_g_r_a_outside[N_GENDER][N_RISK][N_AGE+1];
    
    long n_curr_part_r[N_RISK] = {0,0,0};
    long n_curr_sd_part_r[N_RISK] = {0,0,0};
    long n_curr_part_r_outside[N_RISK] = {0,0,0};
    long n_curr_sd_part_r_outside[N_RISK] = {0,0,0};
    long n_partners_thisyear_r[N_RISK] = {0,0,0};
    long n_lifetime_partners_r[N_RISK] = {0,0,0};
    long n_partners_thisyear_r_outside[N_RISK] = {0,0,0};
    long n_lifetime_partners_r_outside[N_RISK] = {0,0,0};
    
    /* Temporary store of data from current year. */
    char temp_string[20000];
    /* Temporary store for single variable which gets strcat'd into temp_string. */
    char temp_string2[100];
    /* Temporary store for pop size/incidence/prevalence by gender and age gp which gets strcat'd
    into temp_string. */
    char temp_string3[2000]; 
    char temp_string4[2000];
    char temp_string5[2000];

    /* Only output these if not PC data. For PC data we restrict to 18-44 - these outputs below 
    are by age group for all ages. */
    if(PCdata == 0){
        for(r = 0; r < N_RISK; r++){
            for(a = 0; a < (N_AGE + 1); a++){
                for(g = 0; g < N_GENDER; g++){
                    n_lifetime_partners_g_r_a[g][r][a] = 0;
                    n_curr_part_g_r_a[g][r][a] = 0;
                    n_partners_thisyear_g_r_a[g][r][a] = 0;
                    n_lifetime_partners_g_r_a_outside[g][r][a] = 0;
                    n_curr_part_g_r_a_outside[g][r][a] = 0;
                    n_partners_thisyear_g_r_a_outside[g][r][a] = 0;
                    npop_g_r_a[g][r][a] = 0;
                }
            }
        }
    }
    
    for(n_id = 0; n_id < patch[p].id_counter; n_id++){
        /* Check that the person is not dead: */
        if (patch[p].individual_population[n_id].cd4 != DEAD){
            
            g = patch[p].individual_population[n_id].gender;
            
            /* Count number of partners stratified by age, gender and risk group: */
            update_annual_outputs_npartnersbygenderagerisk(&(patch[p].individual_population[n_id]),
                n_lifetime_partners_g_r_a, n_lifetime_partners_g_r_a_outside, n_curr_part_g_r_a,
                n_curr_part_g_r_a_outside, n_partners_thisyear_g_r_a,
                n_partners_thisyear_g_r_a_outside, npop_g_r_a,
                patch[p].age_list->age_list_by_gender[g]->youngest_age_group_index, (float) year);
                
            /* RiskGroup-specific outputs derived here: */
            update_annual_outputs_riskgp(&(patch[p].individual_population[n_id]), npop_r, npos_r,
                n_curr_part_r, n_curr_part_r_outside, n_curr_sd_part_r, n_curr_sd_part_r_outside,
                n_partners_thisyear_r, n_partners_thisyear_r_outside, n_lifetime_partners_r,
                n_lifetime_partners_r_outside);
        }
    }
    
    sprintf(temp_string,"%i,",year);
    
    /* I can't think of a neat way to do this but I would like each outcome for all risk groups
    together in the output file, so wrote this bit of ugly code (could make a function/macro). */

    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_curr_part_r[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_curr_part_r_outside[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_curr_sd_part_r[r]/(1.0*(npop_r[r]-npos_r[r])));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_curr_sd_part_r_outside[r]/(1.0*npop_r[r]-npos_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_partners_thisyear_r[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_partners_thisyear_r_outside[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_lifetime_partners_r[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    for (r=0; r<N_RISK; r++){
        sprintf(temp_string2,"%6.4f,",n_lifetime_partners_r_outside[r]/(1.0*npop_r[r]));
        join_strings_with_check(temp_string, temp_string2, 20000, 
            "temp_string and temp_string2 in store_annual_partnerships_outputs()");
    }
    /* Make sure these are blank: */
    memset(temp_string3, '\0', sizeof(temp_string3));
    memset(temp_string4, '\0', sizeof(temp_string4));
    memset(temp_string5, '\0', sizeof(temp_string5));

    /* Only store these if outputting everything for all age groups. */
    if (PCdata==0){
        /* Make sure these are blank as we are recycling them: */
        memset(temp_string3, '\0', sizeof(temp_string3));
        memset(temp_string4, '\0', sizeof(temp_string4));
        memset(temp_string5, '\0', sizeof(temp_string5));

        for(r=0;r<N_RISK;r++)
            for(a=0;a<(N_AGE+1);a++)
                for(g=0;g<N_GENDER;g++){
                    /* We use temp_string2 as a temp store to convert each number to a string, 
                    then cat that temp string to the relevant temp_string[345]. */

                    if (npop_g_r_a[g][r][a]>0){
                        
                        sprintf(temp_string2,"%6.4f,",
                            (n_curr_part_g_r_a[g][r][a])/(1.0*npop_g_r_a[g][r][a]));
                        join_strings_with_check(temp_string3, temp_string2, 2000, 
                            "temp_string3 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"%6.4f,",
                            (n_curr_part_g_r_a_outside[g][r][a])/(1.0*npop_g_r_a[g][r][a]));
                        join_strings_with_check(temp_string3, temp_string2, 2000, 
                            "temp_string3 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"%6.4f,",
                            n_partners_thisyear_g_r_a[g][r][a]/(1.0*npop_g_r_a[g][r][a]));
                        join_strings_with_check(temp_string4, temp_string2, 2000, 
                            "temp_string4 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"%6.4f,",
                            n_partners_thisyear_g_r_a_outside[g][r][a]/(1.0*npop_g_r_a[g][r][a]));
                        join_strings_with_check(temp_string4, temp_string2, 2000, 
                            "temp_string4 and temp_string2 in store_annual_partnerships_outputs()");

                        sprintf(temp_string2,"%6.4f,",
                            n_lifetime_partners_g_r_a[g][r][a]/(1.0*npop_g_r_a[g][r][a]));
                        join_strings_with_check(temp_string5, temp_string2, 2000, 
                            "temp_string5 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"%6.4f,",
                            n_lifetime_partners_g_r_a_outside[g][r][a]/(1.0*npop_g_r_a[g][r][a]));
                        join_strings_with_check(temp_string5, temp_string2, 2000, 
                            "temp_string5 and temp_string2 in store_annual_partnerships_outputs()");
                    }else{
                        sprintf(temp_string2,"0,");
                        join_strings_with_check(temp_string3, temp_string2, 2000, 
                            "temp_string3 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"0,");
                        join_strings_with_check(temp_string3, temp_string2, 2000, 
                            "temp_string3 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"0,");
                        join_strings_with_check(temp_string4, temp_string2, 2000, 
                            "temp_string4 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"0,");
                        join_strings_with_check(temp_string4, temp_string2, 2000, 
                            "temp_string4 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"0,");
                        join_strings_with_check(temp_string5, temp_string2, 2000, 
                            "temp_string5 and temp_string2 in store_annual_partnerships_outputs()");
                        
                        sprintf(temp_string2,"0,");
                        join_strings_with_check(temp_string5, temp_string2, 2000, 
                            "temp_string5 and temp_string2 in store_annual_partnerships_outputs()");
                    }
                }
        /* Subtract 1 as need to add \n at end. */
        join_strings_with_check(temp_string, temp_string3, 19999, 
            "temp_string and temp_string3 in store_annual_partnerships_outputs()");
        join_strings_with_check(temp_string, temp_string4, 19999, 
            "temp_string and temp_string4 in store_annual_partnerships_outputs()");
        join_strings_with_check(temp_string, temp_string5, 19999, 
            "temp_string and temp_string5 in store_annual_partnerships_outputs()");
    }
    strcat(temp_string,"\n");

    /* This printf statement is not really needed any more, but keeping it for now as a simple way
    to compare outputs to make sure nothing has changed when running the model. */
    if(PCdata==1){
        
        join_strings_with_check(output->annual_partnerships_outputs_string_pconly[p], 
            temp_string, SIZEOF_annual_outputs_string_pconly, 
        "output->annual_partnerships_outputs_string_pconly[p] and temp_string in store_annual_partnerships_outputs()");
        
    }else{
        
        join_strings_with_check(output->annual_partnerships_outputs_string[p], 
            temp_string, SIZEOF_annual_outputs_string,
                "output->annual_partnerships_outputs_string[p] and temp_string in store_annual_partnerships_outputs()");
            
    }
}


void store_timestep_outputs(patch_struct *patch, int p, double t, output_struct *output, 
        int PCdata, int t0, int t_step){
    /* 
    Stores timestep data (such as incidence, prevalence, number on ART, cum numbers of tests etc.)
    for a given time step and state of the epidemic.  
    
    This is a rubbish function just set up to calibrate Pangea quickly.
    There was previously a bug in n_infected so that it did not give the number of prevalent people!
    (due to how they were aged each year). Bug now fixed (Dec 2014).
    
    So I force a count by looping over all individuals.
    Note that n_infected_total is the total current number of HIV+ people - we use it to screen out
    runs where prevalence drops to 0. 
    
    
    Parameters
    ----------
    patch : pointer to a patch_struct
            
    p : int
            Patch index
    t : double
            Year (in decimal) in question
    output : pointer to a output_struct object
            
    PCdata : int (0 or 1)
            Should the counts be restricted to PC-eligible population (18-45 age group)
	t0 : int
			Year in equation
	t_step : int
			Time step in question
    */
    
    int aa, g, r, ai;
    long n_id;
    int MINAGE_COUNTED, MAX_AGE_COUNTED;
    long npop_m = 0;
    long npop_f = 0;
    long npositive_m=0;
    long npositive_f=0;
    long Nknowpositive_m = 0;
    long Nknowpositive_f = 0;
    long NNotKnowStatus_m = 0;
    long NNotKnowStatus_f = 0;
    long NArt_m = 0;
    long NArt_f = 0;
    long NVS_m = 0;
    long NVS_f = 0;
    long N_men_MC = 0;
    long temp_cumulativeinfected;
    char temp_string[5000]; // Temporary store of data from current year.
    char temp_string2[100]; // Temp store for vars by gender/age which gets added to temp_string
    memset(temp_string2, '\0', sizeof(temp_string2));
    
    // If PCdata == 0, include the whole population (aged 13+)
    if(PCdata == 0){
        for(n_id = 0; n_id < patch[p].id_counter; n_id++){
            /* Check that the person is not dead: */
            if(patch[p].individual_population[n_id].cd4 != DEAD){
                
                /* Gender-specific outputs derived here: */
                if(patch[p].individual_population[n_id].gender == MALE){
                    
                    /* Use a function here so easy to add extra stratifications to output: */
                    update_outputs_gender_veryshort(&(patch[p].individual_population[n_id]), 
                            &npop_m, &npositive_m, &Nknowpositive_m, &NArt_m, &NVS_m, 
                            &NNotKnowStatus_m);
                    
                    /* Count number of men who are currently circ: */
                    if (patch[p].individual_population[n_id].circ == VMMC || patch[p].individual_population[n_id].circ==VMMC_HEALING||patch[p].individual_population[n_id].circ==TRADITIONAL_MC){
                        N_men_MC++;
                    }
                }else{
                    update_outputs_gender_veryshort(&(patch[p].individual_population[n_id]), &npop_f, &npositive_f, &Nknowpositive_f, &NArt_f, &NVS_f, &NNotKnowStatus_f);
                }
            }
        }
    }
    // If PCdata == 1, only include people if they are eligible to be in PC at present 
    // (defined as >18 and <45 at this timestep.
    else if(PCdata == 1){
        for (n_id = 0; n_id < patch[p].id_counter; n_id++){
            
            /* Check that the person is not dead: */
            if(patch[p].individual_population[n_id].cd4 != DEAD && (t-patch[p].individual_population[n_id].DoB) > 18 && (t-patch[p].individual_population[n_id].DoB) < 45){
                
                /* Gender-specific outputs derived here: */
                if(patch[p].individual_population[n_id].gender == MALE){
                    /* Use a function here so easy to add extra stratifications to output: */
                    update_outputs_gender_veryshort(&(patch[p].individual_population[n_id]), &npop_m, &npositive_m, &Nknowpositive_m, &NArt_m, &NVS_m, &NNotKnowStatus_m);
                    
                    /* Count number of men who are currently circ: */
                    if(patch[p].individual_population[n_id].circ==VMMC||patch[p].individual_population[n_id].circ==VMMC_HEALING||patch[p].individual_population[n_id].circ==TRADITIONAL_MC){
                        N_men_MC++;
                    }
                }else{
                    update_outputs_gender_veryshort(&(patch[p].individual_population[n_id]), 
                            &npop_f, &npositive_f, &Nknowpositive_f, &NArt_f, &NVS_f, 
                            &NNotKnowStatus_f);
                }
            }
        }
    // If PCdata is not 0 or 1
    }else{
        printf("ERROR: PCdata variable is not defined correctly (should be 0 or 1) - exiting\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    // Write variables to string `temp_string`
    sprintf(temp_string,"%6.4f,%i,%i,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%li,%6.4f,",
        t, (int) floor(t0 + (t_step+1)*TIME_STEP), (t_step + 1)%N_TIME_STEP_PER_YEAR, npop_m, npop_f, npositive_m, npositive_f, Nknowpositive_m, Nknowpositive_f, 
        NArt_m, NArt_f, NVS_m, NVS_f, NNotKnowStatus_m, NNotKnowStatus_f, N_men_MC/(1.0*npop_m));
    
    if(PCdata == 0){
        MINAGE_COUNTED = 0;
        MAX_AGE_COUNTED = MAX_AGE-AGE_ADULT;
    }else{
        MINAGE_COUNTED = 18 - AGE_ADULT;
        MAX_AGE_COUNTED = 45 - AGE_ADULT;
    }
    
    for (g = 0; g < N_GENDER; g++){
        temp_cumulativeinfected = 0;
        
        for(aa = MINAGE_COUNTED; aa < (MAX_AGE_COUNTED); aa++){
            for(r = 0; r < N_RISK; r++){
                
                ai = aa + patch[p].n_infected_cumulative->youngest_age_group_index;
                while (ai > (MAX_AGE-AGE_ADULT-1)){
                    ai = ai - (MAX_AGE - AGE_ADULT);
                }
                temp_cumulativeinfected += patch[p].n_infected_cumulative->pop_size_per_gender_age1_risk[g][ai][r];
            }
        }
        
        /* Only count oldest age group if not restricted to PC age groups: */
        if(PCdata == 0){
            for (r = 0; r < N_RISK; r++){
                temp_cumulativeinfected += patch[p].n_infected_cumulative->pop_size_oldest_age_group_gender_risk[g][r];
            }
        }
        
        /* So don't add an extra comma at the end - which causes issues if reading in this file from R. */
        if (g < (N_GENDER-1)){
            sprintf(temp_string2, "%ld,", temp_cumulativeinfected);
        }else{
            sprintf(temp_string2, "%ld", temp_cumulativeinfected);
        }
        strcat(temp_string, temp_string2);
    }
    
    // Add the string `temp_string` to the timestep_outputs string
    strcat(temp_string,"\n");
    if(PCdata == 1){
        strcat(output->timestep_outputs_string_PConly[p], temp_string);
    }else{
        strcat(output->timestep_outputs_string[p], temp_string);
    }
}




void store_timestep_age_outputs(patch_struct *patch, int p, double t, output_struct *output, 
        int PCdata){
    /* 
    Stores timestep data (such as incidence, prevalence, number on ART, cum numbers of tests etc.)
    for a given time step and state of the epidemic, split by age and gender.  
    
    For ages AGE_ADULT to MAX_AGE (see constants.h for definitions), this file stores age- and 
    gender- specific values at each time step of the following strata of the population:
        * total individuals
        * number of HIV positive individuals
        * number of those aware of status
        * number of those aware on ART
        * number of those on ART that are virally suppressed
    
    These are stored in the character array called `timestep_age_outputs_string` or 
    `timestep_age_outputs_string_PConly` (if we're looking at PC outputs for a specific age range).
    These are written to file in the function write_timestep_age_outputs().  Columns are output for
    each gender and each year of age.  
    
    There are still a few columns in Timestep_outputs* that are not stored as age-stratified
    outputs by this function: 
        * NNotKnowStatus_m
        * NNotKnowStatus_f
        * PropMenCirc
        * Cumulative_Infected_m
        * Cumulative_Infected_f
    
    Parameters
    ----------
    patch : pointer to a patch_struct
            
    p : int
            
    t : double
            
    output : pointer to a output_struct object
            
    PCdata : int (0 or 1)
            Should the counts be restricted to PC-eligible population (18-45 age group)
    */
    
    int AGE_RANGE = MAX_AGE - AGE_ADULT + 1;
    long npop[N_GENDER][AGE_RANGE];
    long npositive[N_GENDER][AGE_RANGE];
    long naware[N_GENDER][AGE_RANGE];
    long nonart[N_GENDER][AGE_RANGE];
    long nvs[N_GENDER][AGE_RANGE];
    //long nnotknowstatus[N_GENDER][AGE_RANGE];
    long cumulative_infected[N_GENDER][AGE_RANGE];
    
     // Temporary store of people in each strata
    char temp_string_npop[100];
    char temp_string_npositive[100];
    char temp_string_naware[100];
    char temp_string_nonart[100];
    char temp_string_nvs[100];
    //char temp_string_nnotknowstatus[100];
    char temp_string_cumulative_infected[100];
    
    int g, a, age;
    long n_id;
    
    // Set counters to zero
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            npop[g][a] = 0;
            npositive[g][a] = 0;
            naware[g][a] = 0;
            nonart[g][a] = 0;
            nvs[g][a] = 0;
            //nnotknowstatus[g][a] = 0;
            cumulative_infected[g][a] = 0;
        }
    }
    
    if(PCdata == 0){
        // Loop through the population
        for(n_id = 0; n_id < patch[p].id_counter; n_id++){
        
            // Check that the person is not dead
            if(patch[p].individual_population[n_id].cd4 != DEAD){
            
                if(patch[p].individual_population[n_id].cd4 < DEAD ||
                    patch[p].individual_population[n_id].cd4 > NCD4){
                
                    printf("Unknown CD4 %i for %li %li in patch %i!!! Exiting\n",
                        patch[p].individual_population[n_id].cd4,
                            n_id, patch[p].individual_population[n_id].id,
                            patch[p].individual_population[n_id].patch_no);
                    printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
                    fflush(stdout);
                    exit(1);
                }
            
                // Calculate age index, use 18-80 year olds
                age = (int) floor(t - patch[p].individual_population[n_id].DoB);
            
                // If age is greater than 80 (or MAX_AGE), lump these people together.  
                if(age > MAX_AGE){
                    age = MAX_AGE;
                }
                a = age - AGE_ADULT;
                g = patch[p].individual_population[n_id].gender;
            
                // Increment the counter
                npop[g][a]++;
            
                if(patch[p].individual_population[n_id].HIV_status > UNINFECTED){
                    npositive[g][a]++;
                
                    if(patch[p].individual_population[n_id].ART_status >= ARTNAIVE && 
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
                            naware[g][a]++;
                    
                        // Check if individual is on ART
                        if(patch[p].individual_population[n_id].ART_status == EARLYART || 
                            patch[p].individual_population[n_id].ART_status == LTART_VS || 
                            patch[p].individual_population[n_id].ART_status == LTART_VU){
                                nonart[g][a]++;
                            
                            // Check if individual is virally suppressed
                            if(patch[p].individual_population[n_id].ART_status == LTART_VS){
                                nvs[g][a]++;
                            }
                        }
                    }
                }
            }
        }
    }else{
        // Loop through the population
        for(n_id = 0; n_id < patch[p].id_counter; n_id++){
        
            // Check that the person is not dead
            if(patch[p].individual_population[n_id].cd4 != DEAD && 
                (t - patch[p].individual_population[n_id].DoB) > AGE_PC_MIN && 
                (t - patch[p].individual_population[n_id].DoB) < (AGE_PC_MAX + 1)
            ){
            
                if(patch[p].individual_population[n_id].cd4 < DEAD ||
                    patch[p].individual_population[n_id].cd4 > NCD4){
                
                    printf("Unknown CD4 %i for %li %li in patch %i!!! Exiting\n",
                        patch[p].individual_population[n_id].cd4,
                            n_id, patch[p].individual_population[n_id].id,
                            patch[p].individual_population[n_id].patch_no);
                    printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
                    fflush(stdout);
                    exit(1);
                }
            
                // Calculate age, use 18-80 year olds
                age = (int) floor(t - patch[p].individual_population[n_id].DoB);
            
                // If age is greater than 80 (or MAX_AGE), lump these people together.  
                if(age > MAX_AGE){
                    age = MAX_AGE;
                }
                // Convert age to an age-index
                a = age - AGE_ADULT;
                g = patch[p].individual_population[n_id].gender;
                
                // Increment the counter of total population
                npop[g][a]++;
                
                // Check if the individual is HIV positive
                if(patch[p].individual_population[n_id].HIV_status > UNINFECTED){
                    npositive[g][a]++;
                    
                    // Check if the individual is aware of status
                    if(patch[p].individual_population[n_id].ART_status >= ARTNAIVE && 
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
                            naware[g][a]++;
                    
                        // Check if individual is on ART
                        if(patch[p].individual_population[n_id].ART_status == EARLYART || 
                            patch[p].individual_population[n_id].ART_status == LTART_VS || 
                            patch[p].individual_population[n_id].ART_status == LTART_VU){
                                nonart[g][a]++;
                            
                            // Check if individual is virally suppressed
                            if(patch[p].individual_population[n_id].ART_status == LTART_VS){
                                nvs[g][a]++;
                            }
                        }
                    }
                }
            }
        }
    }
    
    
    // Add the timestep to the start of the output array
    char temp_string[100];
    sprintf(temp_string,"%6.4f,", t);
    if(PCdata == 0){
        strcat(output->timestep_age_outputs_string[p], temp_string);
    }else{
        strcat(output->timestep_age_outputs_string_PConly[p], temp_string);
    }
    
    // Output population
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            
            sprintf(temp_string_npop,"%ld,", npop[g][a]);
            
            if(PCdata == 0){
                join_strings_with_check(output->timestep_age_outputs_string[p], temp_string_npop,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_string_npop in store_timestep_age_outputs()");
            }else{
                join_strings_with_check(output->timestep_age_outputs_string_PConly[p],
                    temp_string_npop,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_string_npop in store_timestep_age_outputs()");
            }
        }
    }
    
    // Output positive
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            
            sprintf(temp_string_npositive,"%ld,", npositive[g][a]);
            
            if(PCdata == 0){
                join_strings_with_check(output->timestep_age_outputs_string[p],
                    temp_string_npositive,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._npositive in store_timestep_age_outputs()");
                }else{
                    join_strings_with_check(output->timestep_age_outputs_string_PConly[p],
                        temp_string_npositive,
                        SIZEOF_calibration_outputs - 1, 
                        "timestep_outputs_string and temp_..._npositive in store_timestep_age_outputs()");
                }
        }
    }
    
    // Output aware
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            
            sprintf(temp_string_naware,"%ld,", naware[g][a]);
            
            if(PCdata == 0){
                join_strings_with_check(output->timestep_age_outputs_string[p], 
                    temp_string_naware,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._naware in store_timestep_age_outputs()");
            }else{
                join_strings_with_check(output->timestep_age_outputs_string_PConly[p],
                    temp_string_naware,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._naware in store_timestep_age_outputs()");
            }
        }
    }
    
    // Output on ART
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            
            sprintf(temp_string_nonart,"%ld,", nonart[g][a]);
            
            if(PCdata == 0){
                join_strings_with_check(output->timestep_age_outputs_string[p], 
                    temp_string_nonart,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._nonart in store_timestep_age_outputs()");
            }else{
                join_strings_with_check(output->timestep_age_outputs_string_PConly[p], 
                    temp_string_nonart,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._nonart in store_timestep_age_outputs()");
            }
        }
    }
    
    // Output on VS
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            
            sprintf(temp_string_nvs,"%ld,", nvs[g][a]);
            
            if(PCdata == 0){
                join_strings_with_check(output->timestep_age_outputs_string[p], 
                    temp_string_nvs, 
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._nvs in store_timestep_age_outputs()");
            }else{
                join_strings_with_check(output->timestep_age_outputs_string_PConly[p], 
                    temp_string_nvs,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._nvs in store_timestep_age_outputs()");
            }
        }
    }
    
    // Count the cumulative infected
    int ai, aa, r, MINAGE_COUNTED, MAXAGE_COUNTED;
    if(PCdata == 0){
        MINAGE_COUNTED = 0;
        MAXAGE_COUNTED = MAX_AGE - AGE_ADULT;
    }else{
        MINAGE_COUNTED = AGE_PC_MIN - AGE_ADULT;
        MAXAGE_COUNTED = (AGE_PC_MAX + 1) - AGE_ADULT;
    }
    
    for (g = 0; g < N_GENDER; g++){
        for(aa = MINAGE_COUNTED; aa < (MAXAGE_COUNTED); aa++){
            for(r = 0; r < N_RISK; r++){
                
                ai = aa + patch[p].n_infected_cumulative->youngest_age_group_index;
                while(ai > (MAX_AGE - AGE_ADULT - 1)){
                    ai = ai - (MAX_AGE - AGE_ADULT);
                }
                cumulative_infected[g][ai] +=
                    patch[p].n_infected_cumulative->pop_size_per_gender_age1_risk[g][ai][r];
            }
        }
        
        /* Only count oldest age group if not restricted to PC age groups: */
        if(PCdata == 0){
            for(r = 0; r < N_RISK; r++){
                cumulative_infected[g][MAXAGE_COUNTED] +=
                    patch[p].n_infected_cumulative->pop_size_oldest_age_group_gender_risk[g][r];
            }
        }
    }
    
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < AGE_RANGE; a++){
            
            sprintf(temp_string_cumulative_infected,"%ld,", cumulative_infected[g][a]);
            
            if(PCdata == 0){
                join_strings_with_check(output->timestep_age_outputs_string[p], 
                    temp_string_cumulative_infected, 
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._nvs in store_timestep_age_outputs()");
            }else{
                join_strings_with_check(output->timestep_age_outputs_string_PConly[p], 
                    temp_string_cumulative_infected,
                    SIZEOF_calibration_outputs - 1, 
                    "timestep_outputs_string and temp_..._nvs in store_timestep_age_outputs()");
            }
        }
    }
    
    // Add a newline at the end of running this function
    if(PCdata == 0){
        strcat(output->timestep_age_outputs_string[p], "\n");
    }else{
        strcat(output->timestep_age_outputs_string_PConly[p], "\n");
    }
}

/**************************************************************************************************
 ****************************    Calibration output functions    **********************************
***************************************************************************************************/

/* store_person_timesteps_pc

Stores "person timesteps" so that we can calculate incidence.  This function loops through the population and increments a counter for each timestep that an individual is alive and HIV negative.  
It does this for all PC rounds, and by year of age, and by sex.  This is eventually output in the Calibration*.csv files and is written to the output sting in the function store_calibration_outputs_pc.  
*/

void save_person_timesteps_pc(patch_struct *patch, int p, output_struct *output, 
    int t0, int t_step){
    
    int g, a, age, pc_round;
    long n_id;
    // Return the PC round (according to the inside patch)
    pc_round = get_pc_round(t0, t_step, patch, 0);
    double t = t0 + (t_step + 1)*TIME_STEP; 
    
    if(pc_round != -1){
        
        // Loop through the population
        for(n_id = 0; n_id < patch[p].id_counter; n_id++){
            
            // Check that the person is alive
            if(patch[p].individual_population[n_id].cd4 != DEAD){
                
                // Check the individual is HIV negative
                if(patch[p].individual_population[n_id].HIV_status == UNINFECTED){
                
                    g = patch[p].individual_population[n_id].gender;
                    age = (int) floor(t - patch[p].individual_population[n_id].DoB);
                    
                    // Check that the age is within the PC age range
                    if( (age >= AGE_PC_MIN) && (age <= AGE_PC_MAX) ){
                        a = age - AGE_PC_MIN;
                        output->PC_ROUND_PERSON_TIMESTEPS[p][g][a][pc_round]++;
                    }
                }
            }
        }
    }
}


/* save_calibration_outputs_pc

Save "cross-sectional" outputs associated with the PC (this is really the whole simulated population
but within a particular age range.  By sex and year of age, store the size of the total population, 
the number of HIV positive individuals, the number aware, the number on ART, and the number that are
virally suppressed.  
*/
void save_calibration_outputs_pc(patch_struct *patch, int p, output_struct *output, int t0, 
    int t_step){
    
    int pc_round, g, age, a;
    
    // Get PC round according to the inside patch
    pc_round = get_pc_round(t0, t_step, patch, 0);
    
    double t = t0 + (t_step + 1)*TIME_STEP; 
    
    long n_id;
    
    for(n_id = 0; n_id < patch[p].id_counter; n_id++){
        /* Check that the person is not dead: */
        if(patch[p].individual_population[n_id].cd4 != DEAD){
            
            /* Use only 18-44 year olds (or whatever the PC age limits are): */
            age = (int) floor(t - patch[p].individual_population[n_id].DoB);
            
            if((age >= AGE_PC_MIN) && (age <= AGE_PC_MAX)){
                /* use g to make code more readable. */
                g = patch[p].individual_population[n_id].gender;
                a = age - AGE_PC_MIN;
                
                output->PC_NPOP[p][g][a][pc_round]++;
                
                if(patch[p].individual_population[n_id].HIV_status > UNINFECTED){
                    output->PC_NPOSITIVE[p][g][a][pc_round]++;
                    
                    if(patch[p].individual_population[n_id].ART_status >= ARTNAIVE &&
                        patch[p].individual_population[n_id].ART_status < ARTDEATH){
                        output->PC_NAWARE[p][g][a][pc_round]++;
                        
                        if(patch[p].individual_population[n_id].ART_status == EARLYART ||
                            patch[p].individual_population[n_id].ART_status == LTART_VS ||
                            patch[p].individual_population[n_id].ART_status == LTART_VU){
                            output->PC_NONART[p][g][a][pc_round]++;
                            
                            if(patch[p].individual_population[n_id].ART_status == LTART_VS){
                                output->PC_NVS[p][g][a][pc_round]++;
                            }
                        }
                    }
                }
            }
        }
    }
}


/* store_calibration_outputs_pc

Store all the outputs associated with the PC calibration columns into the string array called
output->pc_output_string.  This string is then combined with the additional calibration outputs 
and written to file.  

Store PC outputs in output->pc_output_string[p] array.  These outputs are later copied to 
output->calibration_outputs_combined_string within main.c (after the DHS outputs are added).  The
storage of the PC outputs is called after the CHiPs calibration output is stored.  However some of these PC outputs are calculated earlier in the simulation as the PC cross-section needs to be taken
at a particular time-step, not at the end of a year.  

This function may be replaced or updated at a later stage when PC sampling occurs within the model.
*/
void store_calibration_outputs_pc(patch_struct *patch, int p, output_struct *output){
    
    int g, a, pc_round;
    
    char temp_string_n[300]; /* Temporary store of number of people in a population subgroup. */
    char temp_string_pos[300]; /* Temporary store of number of HIV+ in a population subgroup. */
    char temp_string_aware[300];
    char temp_string_onart[300];
    char temp_string_vs[300];
    char temp_string_ninc[300];
    char temp_string_inc[300];
    char temp_string_py[300];
    
    for(pc_round = 0; pc_round < NPC_ROUNDS; pc_round++){
        
        // Store number of individuals in the population, per age and sex
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_n, "%ld,", output->PC_NPOP[p][g][a][pc_round]);
                join_strings_with_check(output->pc_output_string[p], temp_string_n,
                    SIZEOF_calibration_outputs-1, 
                    "pc_output_string and temp_string_n in store_calibration_outputs_pc()");
            }
        }
    
        // Store number of HIV+ individuals in the population, per age and sex
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_pos,"%ld,", output->PC_NPOSITIVE[p][g][a][pc_round]);
                join_strings_with_check(output->pc_output_string[p], temp_string_pos,
                    SIZEOF_calibration_outputs-1, 
                    "pc_output_string and temp_string_pos in store_calibration_outputs_pc()");
            }
        }
    
        // Store number of HIV+ individuals in the population aware of HIV status, per age and sex
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_aware,"%ld,", output->PC_NAWARE[p][g][a][pc_round]);
                join_strings_with_check(output->pc_output_string[p], temp_string_aware,
                    SIZEOF_calibration_outputs-1, 
                    "pc_output_string and temp_string_aware in store_calibration_outputs_pc()");
            }
        }
    
        // Store number of HIV+ individuals aware of HIV status that are on ART, per age and sex
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_onart,"%ld,", output->PC_NONART[p][g][a][pc_round]);
                join_strings_with_check(output->pc_output_string[p], temp_string_onart,
                    SIZEOF_calibration_outputs-1, 
                    "pc_output_string and temp_string_onart in store_calibration_outputs_pc()");
            }
        }
    
        // Store number of HIV+ individuals aware of HIV status that are on ART and VS, per age and sex
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_vs,"%ld,", output->PC_NVS[p][g][a][pc_round]);
                join_strings_with_check(output->pc_output_string[p], temp_string_vs,
                    SIZEOF_calibration_outputs-1, 
                    "pc_output_string and temp_string_vs in store_calibration_outputs_pc()");
            }
        }
        
        // Store N incident cases per age and sex
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_ninc,"%ld,",
                    output->PC_ROUND_INFECTIONS[p][g][a][pc_round]);
                join_strings_with_check(output->pc_output_string[p], temp_string_ninc,
                    SIZEOF_calibration_outputs-1,
                    "pc_output_string and temp_string_ninc in store_calibration_outputs_pc()");
            }
        }
        
        // Store incidence rate
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){
                sprintf(temp_string_inc,"%lf,", 
                (double) output->PC_ROUND_INFECTIONS[p][g][a][pc_round]/(output->PC_ROUND_PERSON_TIMESTEPS[p][g][a][pc_round]/N_TIME_STEP_PER_YEAR));
                join_strings_with_check(output->pc_output_string[p], temp_string_inc,
                    SIZEOF_calibration_outputs-1,
                    "pc_output_string and temp_string_inc in store_calibration_outputs_pc()");
            }
        }

        // Store person-years
        for(g = 0; g < N_GENDER; g++){
            for(a = 0; a < PC_AGE_RANGE_MAX; a++){

                // If we're printing the last entry, then don't add a trailing comma
                if(
                    (g == (N_GENDER - 1)) &&
                    (a == (PC_AGE_RANGE_MAX - 1)) &&
                    (pc_round == (NPC_ROUNDS - 1))
                ){
                    sprintf(temp_string_py,"%lf",
                         (double) output->PC_ROUND_PERSON_TIMESTEPS[p][g][a][pc_round]/N_TIME_STEP_PER_YEAR);
                }else{
                    sprintf(temp_string_py,"%lf,", 
                        (double) output->PC_ROUND_PERSON_TIMESTEPS[p][g][a][pc_round]/N_TIME_STEP_PER_YEAR);
                }

                join_strings_with_check(output->pc_output_string[p], temp_string_py,
                    SIZEOF_calibration_outputs-1,
                    "pc_output_string and temp_string_py in store_calibration_outputs_pc()");
            }
        }
    }
}


/* Store data at the time of the given DHS round. This will eventually be written in the file Calibration_output.csv. */
void store_calibration_outputs_dhs(patch_struct *patch, int p, output_struct *output, int year){
    long n_id;
    int g, a;
    long totpop[N_GENDER];
    long totpop_uninf[N_GENDER];

    long npop[N_GENDER][DHS_AGE_RANGE_MAX];
    long npositive[N_GENDER][DHS_AGE_RANGE_MAX];
    long tested_last_year[N_GENDER]; //this is the number who received a test through dhs
    for (g=0;g<N_GENDER;g++){
        for (a=0;a<DHS_AGE_RANGE_MAX; a++){
            npop[g][a] = 0;
            npositive[g][a] = 0;
        }
        totpop[g]=0;
        tested_last_year[g]=0;
        totpop_uninf[g]=0;
    }
    //printf("Accessing store_calibration_outputs_dhs() in year %i\n",year);
    char temp_string_n[100]; /* Temporary store of number of people in a population subgroup. */
    char temp_string_pos[100]; /* Temporary store of number of HIV+ in a population subgroup. */
    char temp_string_tested[100];
    for (n_id=0; n_id<patch[p].id_counter; n_id++){
        /* Check that the person is not dead: */
        if (patch[p].individual_population[n_id].cd4!=DEAD){
            if (patch[p].individual_population[n_id].cd4<DEAD || patch[p].individual_population[n_id].cd4>4){
                printf("Unknown CD4 %i for %li %li in patch %i!!! Exiting\n",patch[p].individual_population[n_id].cd4,n_id,patch[p].individual_population[n_id].id,patch[p].individual_population[n_id].patch_no);
                printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
                fflush(stdout);
                exit(1);
            }
            /* Use only 15-59 year olds (or whatever the DHS age limits are): */
            
            a = (int) floor(year-patch[p].individual_population[n_id].DoB);
            if ((a>=AGE_DHS_MIN) && (a<=AGE_DHS_MAX)){
                if ((year+1 - patch[p].individual_population[n_id].time_last_hiv_test_routine <=1.0) && (year+1 - patch[p].individual_population[n_id].time_last_hiv_test_routine >=0)){
                tested_last_year[patch[p].individual_population[n_id].gender]++;
                }

                g = patch[p].individual_population[n_id].gender; /* use g to make code more readable. */
                totpop[g]++;
                
                npop[g][a-AGE_DHS_MIN]++;
                if (patch[p].individual_population[n_id].HIV_status>UNINFECTED){
//                  if (year>2005){
//                      printf("Infection %i %i\n",g,a);
//                  }
                    npositive[g][a-AGE_DHS_MIN]++;
                }
                else{
                    totpop_uninf[g]++;
                }

            }
        }
    }


    for (g=0;g<N_GENDER;g++){
        for (a=0;a<DHS_AGE_RANGE_MAX; a++){
            sprintf(temp_string_n,"%ld,",npop[g][a]);
            join_strings_with_check(output->dhs_output_string[p], temp_string_n, SIZEOF_calibration_outputs-1, "dhs_output_string and temp_string_n in store_calibration_outputs_dhs()");
        }
    }

    for (g=0;g<N_GENDER;g++){
        for (a=0;a<DHS_AGE_RANGE_MAX; a++){
            sprintf(temp_string_pos,"%ld,",npositive[g][a]);
            join_strings_with_check(output->dhs_output_string[p], temp_string_pos, SIZEOF_calibration_outputs-1, "dhs_output_string and temp_string_pos in store_calibration_outputs_dhs()");
        }
    }
    for (g=0;g<N_GENDER;g++){
        sprintf(temp_string_tested,"%f,",(tested_last_year[g]+0.0)/(totpop[g]+0.0));
        
        //printf("%lf, %ld, %ld\n",tested_last_year[g]/(totpop[g]+0.0), totpop[g],totpop_uninf[g]);
        join_strings_with_check(output->dhs_output_string[p], temp_string_tested, SIZEOF_calibration_outputs-1, "dhs_output_string and temp_string_tested in store_calibration_outputs_dhs()");
    }
}

/* store drug resistance prevalence for a given year */
void store_calibration_outputs_DR(patch_struct *patch, int p, output_struct *output, int year){
    long n_id;
    int a;
    //in the model, DR status is assigned at start of ART, so the denominator for checkin prevalence in ART starters
    long n_pos_ART_start[DR_AGE_RANGE_MAX];
    long n_pos_ART_start_DR[DR_AGE_RANGE_MAX];
    for (a=0;a<DR_AGE_RANGE_MAX; a++){
            n_pos_ART_start[a] = 0;
            n_pos_ART_start_DR[a] = 0;
    }
    char temp_string_ART[100]; /* Temporary store of number of ART experienced people in a population subgroup. */
    char temp_string_ART_DR[100]; /* Temporary store of number of ART experienced with DR in a population subgroup. */

    for (n_id=0; n_id<patch[p].id_counter; n_id++){
        //if(year == 2014 && patch[p].individual_population[n_id].id ==64836){
         //               printf("individual with id %ld started ART at %lf and is ... %i\n",patch[p].individual_population[n_id].id,patch[p].individual_population[n_id].PANGEA_date_firstARTstart,patch[p].individual_population[n_id].cd4);
        //}
        /* Check that the person is not dead at the start of the year: */
        //if (patch[p].individual_population[n_id].cd4!=DEAD){
        if (patch[p].individual_population[n_id].DoD>(year-1) || patch[p].individual_population[n_id].DoD==-1){
            
            /* Count within DR age range*/
            a = (int) floor(year-patch[p].individual_population[n_id].DoB);
            
            if((a>=AGE_DR_MIN) && (a<=MAX_AGE)){
                // Initiated ART for the first time in the last year
                if((year - patch[p].individual_population[n_id].last_start_art) <= 1.0 && (year - patch[p].individual_population[n_id].last_start_art) >=0){
                    n_pos_ART_start[a-AGE_DR_MIN]++;
                }
                // How many of the new starters were had DR
                if(((year - patch[p].individual_population[n_id].last_start_art) <= 1.0 && (year - patch[p].individual_population[n_id].last_start_art) >=0) && patch[p].individual_population[n_id].drug_resistant == 1){
                    n_pos_ART_start_DR[a-AGE_DR_MIN]++;
                }
            }
        }

    }
    
    for (a=0;a<DR_AGE_RANGE_MAX; a++){
            sprintf(temp_string_ART,"%ld,",n_pos_ART_start[a]);
            join_strings_with_check(output->DR_output_string[p], temp_string_ART, SIZEOF_calibration_outputs-1, "DR_output_string and temp_string_ART in store_calibration_outputs_DR()");

    }

    for (a=0;a<DR_AGE_RANGE_MAX; a++){
            sprintf(temp_string_ART_DR,"%ld,",n_pos_ART_start_DR[a]);
            join_strings_with_check(output->DR_output_string[p], temp_string_ART_DR, SIZEOF_calibration_outputs-1, "DR_output_string and temp_string_ART_DR in store_calibration_outputs_DR()");
    }
}

void store_calibration_outputs_chips(patch_struct *patch, int p, output_struct *output){
    /* Stores data for each CHiPs round (to be written to the calibration files)
    
    This will output a set of columns for each CHiPs round.  The macro determining the number of 
    rounds to be output is called NCHIPSROUNDSFORFITTING and is set in constants.h.  
    
    Outputs the following: 
    * number visited by CHiPs teams
    * number HIV positive
    * number positive who are aware of status
    * number positive on ART
    * number positive on ART who are virally suppressed
    
    Arguments
    ---------
    patch : pointer to patch_struct object
        Array of patch_struct objects (one for each patch)
    
    p : int
        Patch number
    
    output : pointer to an output_struct struct
    
    Returns
    -------
    Nothing; adds text to output->calibration_outputs_combined_string[p] for each patch (p)
    
    */
    int g, ac, chips_round;
    
    /* Temporary store of number of people in a given population subgroup. */
    char temp_string[100];
    
    // Loop through the CHiPs rounds of interest; only generate output for rounds that are being
    // used for parameterisation.  The macro NCHIPSROUNDSFORFITTING is set in constants.h.  
    for(chips_round = 0; chips_round < NCHIPSROUNDSFORFITTING; chips_round++){
        
        // Record the number of individuals visited by CHiPs teams
        for(g = 0; g < N_GENDER; g++){
            for(ac = 0; ac < (MAX_AGE - AGE_CHIPS + 1); ac++){
                
                sprintf(temp_string,"%li,", output->NCHIPS_VISITED[p][g][ac][chips_round]);
                
                join_strings_with_check(output->calibration_outputs_combined_string[p],
                    temp_string, SIZEOF_calibration_outputs - 1, 
                    "calibration_outputs_combined_string and temp_string in "
                    "store_calibration_outputs_chips()");
            }
        }
        // Record the number HIV positive
        for(g = 0; g < N_GENDER; g++){
            for(ac = 0; ac < (MAX_AGE - AGE_CHIPS + 1); ac++){
                
                sprintf(temp_string,"%li,", output->NCHIPS_HIVPOS[p][g][ac][chips_round]);
                
                join_strings_with_check(output->calibration_outputs_combined_string[p],
                    temp_string, SIZEOF_calibration_outputs - 1, 
                    "calibration_outputs_combined_string and temp_string in "
                    "store_calibration_outputs_chips()");
            }
        }
        // Record the number HIV positive that are aware of status
        for(g = 0; g < N_GENDER; g++){
            for(ac = 0; ac < (MAX_AGE - AGE_CHIPS + 1); ac++){
                
                sprintf(temp_string,"%li,", output->NCHIPS_HIVAWARE[p][g][ac][chips_round]);
                join_strings_with_check(output->calibration_outputs_combined_string[p],
                    temp_string, SIZEOF_calibration_outputs - 1, 
                    "calibration_outputs_combined_string and temp_string in "
                    "store_calibration_outputs_chips()");
            }
        }
        // Record the number positive that are on ART
        for(g = 0; g < N_GENDER; g++){
            for(ac = 0; ac < (MAX_AGE - AGE_CHIPS + 1); ac++){
                
                sprintf(temp_string,"%li,",output->NCHIPS_ONART[p][g][ac][chips_round]);
                
                join_strings_with_check(output->calibration_outputs_combined_string[p],
                    temp_string, SIZEOF_calibration_outputs - 1, 
                    "calibration_outputs_combined_string and temp_string in "
                    "store_calibration_outputs_chips()");
            }
        }
        // Record number positive on ART who are virally suppressed
        for(g=0; g<N_GENDER; g++){
            for(ac = 0; ac < (MAX_AGE - AGE_CHIPS + 1); ac++){
                sprintf(temp_string,"%li,", output->NCHIPS_VS[p][g][ac][chips_round]);
                
                join_strings_with_check(output->calibration_outputs_combined_string[p],
                    temp_string, SIZEOF_calibration_outputs-1, 
                    "calibration_outputs_combined_string and temp_string in "
                    "store_calibration_outputs_chips()");
            }
        }
    }
}


void blank_calibration_output_file(char *calibration_output_filename, int NDHSROUNDS){
    /*  Generate (and write) header file for calibration outputs
    
    This writes the header for the calibration file to disk.  
    */
    
    int r, a; /* Indices for DHS round and age. */
    int dr_year, dr_age; /* Indies for drug-resistance year and age*/
    /* Open and close this file to ensure it is blank at the beginning of run as we afterwards
    append data to it. */
    FILE *TEMPFILE;
    TEMPFILE = fopen(calibration_output_filename, "w");
    fprintf(TEMPFILE, "RunNumber,RandomSeed,");
    
    for(r = 1; r <= NDHSROUNDS; r++){
        for(a = AGE_DHS_MIN; a <= AGE_DHS_MAX; a++)
            fprintf(TEMPFILE, "DHSRound%iNtotM%i,", r, a);
        for(a = AGE_DHS_MIN; a <= AGE_DHS_MAX; a++)
            fprintf(TEMPFILE, "DHSRound%iNtotF%i,", r, a);
        for(a = AGE_DHS_MIN; a <= AGE_DHS_MAX; a++)
            fprintf(TEMPFILE, "DHSRound%iNposM%i,", r, a);
        for(a = AGE_DHS_MIN; a <= AGE_DHS_MAX; a++)
            fprintf(TEMPFILE, "DHSRound%iNposF%i,", r, a);
        fprintf(TEMPFILE, "DHSRound%iptestedM,",r);
        fprintf(TEMPFILE, "DHSRound%iptestedF,",r);

    }
    // Write prevalence of drug resistance to file.
    for(dr_year = YEAR_DR_MIN; dr_year <= YEAR_DR_MAX; dr_year++){
        for(dr_age = AGE_DR_MIN; dr_age <= MAX_AGE; dr_age++){
            fprintf(TEMPFILE, "DRYEAR%iARTstartAGE%i,", dr_year, dr_age);
        }
        for(dr_age = AGE_DR_MIN; dr_age <= MAX_AGE; dr_age++){
            /* Last entry should have a new-line rather than a comma. */
            fprintf(TEMPFILE, "DRYEAR%iDRposAGE%i,", dr_year, dr_age);
        }

    }
    // Write headers for number visited by chips, number positive, number aware of status, 
    // number on ART, and number virally suppressed.  
    for(r = 1; r <= NCHIPSROUNDSFORFITTING; r++){
        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNtotM%i,", r, a);
        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNtotF%i,", r, a);

        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNposM%i,", r, a);
        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNposF%i,", r, a);

        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE,"CHIPSRound%iNawareM%i,",r,a);
        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNawareF%i,",r,a);

        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNonARTM%i,", r, a);
        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNonARTF%i,", r, a);

        for(a = AGE_CHIPS; a <= MAX_AGE; a++)
            fprintf(TEMPFILE, "CHIPSRound%iNvsM%i,", r, a);
        for(a = AGE_CHIPS; a <= MAX_AGE; a++){
            fprintf(TEMPFILE, "CHIPSRound%iNvsF%i,", r, a);
        }
    }
    
    // Write PC columns to file.  
    for(r = 0; r < NPC_ROUNDS; r++){
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNtotM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNtotF%i,", r*12, a);

        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNposM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNposF%i,", r*12, a);

        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE,"PC%iNawareM%i,",r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNawareF%i,",r*12, a);

        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNonARTM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNonARTF%i,", r*12, a);

        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNvsM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++){
            fprintf(TEMPFILE, "PC%iNvsF%i,", r*12, a);
        }
        
        // Incident cases
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iNincM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++){
            fprintf(TEMPFILE, "PC%iNincF%i,", r*12, a);
        }
        
        // Incidence rate
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iIncM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++){
            fprintf(TEMPFILE, "PC%iIncF%i,", r*12, a);
        }
        
        // Person years
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++)
            fprintf(TEMPFILE, "PC%iPYM%i,", r*12, a);
        for(a = AGE_PC_MIN; a <= AGE_PC_MAX; a++){
            /* Last entry should have a new-line rather than a comma. */
            if(a == AGE_PC_MAX && r == NPC_ROUNDS - 1)
                fprintf(TEMPFILE, "PC%iPYF%i\n", r*12, a);
            else
                fprintf(TEMPFILE, "PC%iPYF%i,", r*12, a);
        }
    }
    

    fclose(TEMPFILE);
}


/* Writes out the calibration_outputs_combined_string into the Calibration_output csv file (this is done periodically, not every single run): */
void write_calibration_outputs(char *output_filename, output_struct * output, int p){
    FILE *output_file;
    output_file = fopen(output_filename,"a");
    fprintf(output_file,"%s",output->calibration_outputs_combined_string[p]);
    fclose(output_file);
}


void write_annual_outputs(file_struct *file_data_store, output_struct *output, int p){
    /* Write annual_outputs_string (an attribute of an output_struct) into a file.  
    
    Arguments
    ---------
    file_data_store : pointer to a file_struct structure
        Structure with information on filenames to be used for writing.  
    output : pointer to a output_struct structure
        Output structure where the strings to be written to file are stored.  
    p : int
        Patch of interest
    
    Returns
    -------
    Nothing; strings are written to file.  
    */
    int a;
    int r;
    
    /* Open connection to the patch-specific file where annual outputs are to be written to file */
    file_data_store->ANNUAL_OUTPUT_FILE[p] = fopen(file_data_store->filename_annual_output[p], "w");
    
    if(file_data_store->ANNUAL_OUTPUT_FILE[p] == NULL){
        printf("Cannot open annual_output file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    
    /* Print the header of the file */
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"Year,Prevalence,PropAware,Incidence,NumberPositive,NumberDrugResistant,NumberDrugResistantVU,NumberARTexperienced,NumberInitFailARTlastYear,NumberInitSuccessARTlastYear,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"NewCasesThisYear,NewCasesThisYearFromOutside,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"NewCasesThisYearFromAcute,NewCasesThisYearFromDrugResistant,NewCasesThisYearFromDrugResistantVU,PropHIVPosONART,PropVirallySuppressed,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"NAnnual,TotalPopulation,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
        "NumberPositiveM,NumberAwareM,PopulationM,NumberPositiveF,NumberAwareF,PopulationF,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
        "CumulativeNonPopartHIVtests,CumulativePopartHIVtests,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
        "CumulativeNonPopartCD4tests,CumulativePopartCD4tests,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
        "NHIVTestedThisYear,NOnARTM,NVirallySuppressedM,NNeedARTM,NOnARTF,NVirallySuppressedF,NNeedARTF,");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
        "PropMenCirc,NindInSdPart,NDied_from_HIV,NHIV_pos_dead,N_dead,");
    
    for(r = 0; r < N_RISK; r++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"Prop_risk%s,",RISK_GP_NAMES[r]);
    }
    for(r = 0; r < N_RISK; r++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"Prevalence_risk%s,",RISK_GP_NAMES[r]);
    }
    for(r = 0; r < N_RISK; r++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"NewCasesThisYear_risk%s,",RISK_GP_NAMES[r]);
    }
    for(r = 0; r < N_RISK; r++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],"NDied_from_HIV_risk%s,",RISK_GP_NAMES[r]);
    }
    
    //if (PCdata==0){
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
            "NMage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p],
            "NFage%i-%i,", AGE_GROUPS_WITH_OLD[a],AGE_GROUPS_WITH_OLD[a+1]);
    }
    
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "IncMage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "IncFage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "NPosMage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "NPosFage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "NARTMage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "NARTFage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }    
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "NViralSuppMage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }
    for(a = 0; a < N_AGE; a++){
        fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], 
            "NViralSuppFage%i-%i,", AGE_GROUPS_WITH_OLD[a], AGE_GROUPS_WITH_OLD[a+1]);
    }

    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], "\n");
    fprintf(file_data_store->ANNUAL_OUTPUT_FILE[p], "%s\n", output->annual_outputs_string[p]);
    fclose(file_data_store->ANNUAL_OUTPUT_FILE[p]);
}


void write_annual_partnerships_outputs(file_struct *file_data_store, output_struct *output, int p){
    int r, a;


    file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p] = fopen(file_data_store->filename_annual_partnership_output[p],"w");
    if (file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p]==NULL){
        printf("Cannot open annual_partnerships_output file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }


    fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"Year,");
    /*fprintf(annual_output_file,"Year,Prevalence,Incidence,NumberPositive,NewCasesThisYear,PropAnnualAcute,PropHIVPosONART,NAnnual,TotalPopulation,NumberPositiveM,PopulationM,NumberPositiveF,PopulationF,CumulativeNonPopartHIVtests,CumulativePopartHIVtests,CumulativeNonPopartCD4tests,CumulativePopartCD4tests,NHIVTestedThisYear,NOnARTM,NNeedARTM,NOnARTF,NNeedARTF,PropMenCirc,NindInSdPart,NDied_from_HIV,NHIV_pos_dead,N_dead,");*/
    /*for (r=0; r<N_RISK; r++)
        fprintf(annual_partnerships_output_file,"Prop_risk%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(annual_partnerships_output_file,"Prevalence_risk%s,",RISK_GP_NAMES[r]);*/
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentpart_risk%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentpart_risk_outside%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentsdpart_risk%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentsdpart_risk_outside%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNewPartnersthisyear_risk%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNewPartnersthisyear_risk_outside%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNlifetimepart_risk%s,",RISK_GP_NAMES[r]);
    for (r=0; r<N_RISK; r++)
        fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNlifetimepart_risk_outside%s,",RISK_GP_NAMES[r]);


    for(r=0;r<N_RISK;r++)
        for(a=0;a<(N_AGE+1);a++){
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentpart_gend_risk_age_M_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentpart_gend_risk_age_M_outside_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentpart_gend_risk_age_F_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNcurrentpart_gend_risk_age_F_outside_risk%i_age%i,",r,a);
        }
    for(r=0;r<N_RISK;r++)
        for(a=0;a<(N_AGE+1);a++){
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNewPartnersthisyear_gend_risk_age_M_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNewPartnersthisyear_gend_risk_age_M_outside_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNewPartnersthisyear_gend_risk_age_F_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNewPartnersthisyear_gend_risk_age_F_outside_risk%i_age%i,",r,a);
        }
    for(r=0;r<N_RISK;r++)
        for(a=0;a<(N_AGE+1);a++){
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNlifetimepart_gend_risk_age_M_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNlifetimepart_gend_risk_age_M_outside_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNlifetimepart_gend_risk_age_F_risk%i_age%i,",r,a);
            fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"MeanNlifetimepart_gend_risk_age_F_outside_risk%i_age%i,",r,a);
        }



    fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"\n");

    fprintf(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p],"%s\n",output->annual_partnerships_outputs_string[p]);
    fclose(file_data_store->ANNUAL_PARTNERSHIP_OUTPUT_FILE[p]);
}


void write_timestep_outputs(file_struct *file_data_store, output_struct *output, int p, int PCdata){
    /*
    Writes out the timestep_outputs_string into a file
    the timestep_outputs_string is populated using the function store_timestep_outputs()
    
    Parameters
    ----------
    file_data_store : pointer to file_struct
        Assumes that `file_data_store` has an attribute `filename_timestep_output` and 
        `filename_timestep_output_PConly`
    output : pointer to output_struct
        
    p : int 
        Patch number (used to reference 
    PCdata : int 
        Boolean for whether we're outputting PC data or not
        
    */
    
    /* Write to correct file: */
    if (PCdata == 0){
        file_data_store->TIMESTEP_OUTPUT_FILE[p] = fopen(file_data_store->filename_timestep_output[p],"w");
    }else{
        file_data_store->TIMESTEP_OUTPUT_FILE[p] = fopen(file_data_store->filename_timestep_output_PConly[p],"w");
    }
    if (file_data_store->TIMESTEP_OUTPUT_FILE[p] == NULL){
        printf("Cannot open timestep_output_file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    
    // Write the header file
    fprintf(file_data_store->TIMESTEP_OUTPUT_FILE[p],"Time,Year,Timestep,N_m,N_f,NPos_m,NPos_f,N_knowpos_m,N_knowpos_f,NART_m,NART_f,NVS_m,NVS_f,NNotKnowStatus_m,NNotKnowStatus_f,PropMenCirc,Cumulative_Infected_m,Cumulative_Infected_f\n");
    
    if (PCdata == 0){
        fprintf(file_data_store->TIMESTEP_OUTPUT_FILE[p],"%s\n",output->timestep_outputs_string[p]);
    }else{
        fprintf(file_data_store->TIMESTEP_OUTPUT_FILE[p],"%s\n",output->timestep_outputs_string_PConly[p]);
    }
    // Close the connection to the file
    fclose(file_data_store->TIMESTEP_OUTPUT_FILE[p]);
}


void write_timestep_age_outputs(file_struct *file_data_store, output_struct *output, 
    int p, int PCdata){
    /*
    Writes out the timestep_age_outputs_string into a file
    the timestep_age_outputs_string is populated using the function store_timestep_age_outputs()
    
    For ages AGE_ADULT to MAX_AGE (see constants.h for definitions), this file outputs age- and 
    gender- specific values at each time step of the following strata of the population:
        * total individuals
        * number of HIV positive individuals
        * number of those aware of status
        * number of those aware on ART
        * number of those on ART that are virally suppressed
    
    These are output in columns for each gender and each year of age.  
    
    The PConly file outputs only for ages in the PC (see constants.h for definitions of AGE_PC_MIN
    and AGE_PC_MAX).  
    
    Parameters
    ----------
    file_data_store : pointer to file_struct
        Assumes that `file_data_store` has an attribute `filename_timestep_output` and 
        `filename_timestep_output_PConly`
    output : pointer to output_struct
        
    p : int 
        Patch number (used to reference 
    PCdata : int 
        Boolean for whether we're outputting PC data or not
    */
    
    /* Write to correct file: */
    if (PCdata == 0){
        file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p] =
            fopen(file_data_store->filename_timestep_age_output[p], "w");
    }else{
        file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p] = 
            fopen(file_data_store->filename_timestep_age_output_PConly[p], "w");
    }
    if (file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p] == NULL){
        printf("Cannot open timestep_age_output_file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    
    // Write the header file
    fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "Time,");
    
    int a, g;
    
    for(g = 0; g < N_GENDER; g++){
        if(g == MALE){
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NtotM%i,", a);
            }
        }else{
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NtotF%i,", a);
            }
        }
    }
    
    for(g = 0; g < N_GENDER; g++){
        if(g == MALE){
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NposM%i,", a);
            }
        }else{
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NposF%i,", a);
            }
        }
    }
    
    for(g = 0; g < N_GENDER; g++){
        if(g == MALE){
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NawareM%i,", a);
            }
        }else{
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NawareF%i,", a);
            }
        }
    }
    
    for(g = 0; g < N_GENDER; g++){
        if(g == MALE){
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NonARTM%i,", a);
            }
        }else{
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NonARTF%i,", a);
            }
        }
    }
    
    for(g = 0; g < N_GENDER; g++){
        if(g == MALE){
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NvsM%i,", a);
            }
        }else{
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "NvsF%i,", a);
            }
        }
    }
    
    for(g = 0; g < N_GENDER; g++){
        if(g == MALE){
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], 
                    "Cumulative_Infected_m%i,", a);
            }
        }else{
            for(a = AGE_ADULT; a <= MAX_AGE; a++){
                // If it's the last entry, then don't append a comma
                if(a == MAX_AGE){
                    fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], 
                        "Cumulative_Infected_f%i", a);
                }else{
                    fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], 
                        "Cumulative_Infected_f%i,", a);
                }
            }
        }
    }
    
    // Add newline after the header
    fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "\n");
    
    
    // Write the body of the file
    if(PCdata == 0){
        fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "%s\n",
            output->timestep_age_outputs_string[p]);
    }else{
        fprintf(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p], "%s\n",
            output->timestep_age_outputs_string_PConly[p]);
    }
    // Close the connection to the file
    fclose(file_data_store->TIMESTEP_AGE_OUTPUT_FILE[p]);
}


/**************************************************************************************************
 *******************************    Phylogenetics output functions     ****************************
 *************************************************************************************************/

/* Function generates output on transmission for phylogenetics to the global string phylogenetics_output_string
 * which has the output sent to the TRM file (ie the file recording transmission events).
 * Outputs are person infecting, infectee (ie the person who got infected), time of infection, 
 * whether infecting partner was acute. 
 */
/* NOTE: if we change the output from this function then we may need to alter the size of the string array phylogenetics_output_string[] in constants.h */
void store_phylogenetic_transmission_output(output_struct *output, double time, individual* infectee, individual* infector, file_struct *file_data_store, int t0, int t_step){

    ////// MEMORY CHECK THIS
    char temp_string[100]; /* Temporary store of data from one transmission event. */
    long who_infected_id = infector->id;
    long new_infectee_id = infectee->id;
    
    int partner_is_acute;
    if(infector->HIV_status == ACUTE){
        partner_is_acute = 1;
    }else{
        partner_is_acute = 0;
    }
    
    int partner_on_art = infector->ART_status;
    
    int infector_out_patch;
    if (infector->patch_no == infectee->patch_no){
        infector_out_patch = 0;
    }else{
        infector_out_patch = 1;
    }
    
    double SPVL_infector = infector->SPVL_num_E + infector->SPVL_num_G; /* Log10(SPVL). */
    double SPVL_infectee = infectee->SPVL_num_E + infectee->SPVL_num_G;
    
	// Risk group of infected individual
	char infected_risk_text[2];
	if(infectee->sex_risk == LOW){
		sprintf(infected_risk_text,"L");
	}else if(infectee->sex_risk == MEDIUM){
		sprintf(infected_risk_text,"M");
	}else if(infectee->sex_risk == HIGH){
		sprintf(infected_risk_text,"H");
	}else{
        printf("Unknown Sexual Risk Group\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
	
	// Risk group of individual responsible for infection
	char infector_risk_text[2];
	if(infector->sex_risk == LOW){
		sprintf(infector_risk_text,"L");
	}else if(infector->sex_risk == MEDIUM){
		sprintf(infector_risk_text,"M");
	}else if(infector->sex_risk == HIGH){
		sprintf(infector_risk_text,"H");
	}else{
        printf("Unknown Sexual Risk Group\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
	
    /* Format output: */
    if (infector->gender==MALE)
        sprintf(temp_string,"%li,%li,%9.6lf,%i,%i,%i,%i,%i,%i,%6.4lf,%6.4lf,%i,M,%s,%s,%.2lf,%.2lf,%i,%i,%i,%i\n",
			who_infected_id,new_infectee_id,time,t0,t_step, partner_is_acute,partner_on_art,
			infector_out_patch,infector->cd4,SPVL_infector,SPVL_infectee,infector->n_partners,
			infected_risk_text,infector_risk_text,infectee->DoB,infector->DoB,infector->drug_resistant,infectee->drug_resistant,infector->cascade_round,infectee->cascade_round);
    else
        sprintf(temp_string,"%li,%li,%9.6lf,%i,%i,%i,%i,%i,%i,%6.4lf,%6.4lf,%i,F,%s,%s,%.2lf,%.2lf,%i,%i,%i,%i\n",
			who_infected_id,new_infectee_id,time,t0,t_step, partner_is_acute,partner_on_art,
			infector_out_patch,infector->cd4,SPVL_infector,SPVL_infectee,infector->n_partners,
			infected_risk_text,infector_risk_text,infectee->DoB,infector->DoB,infector->drug_resistant,infectee->drug_resistant,infector->cascade_round,infectee->cascade_round);
    
    //print_here_string(temp_string,0);
    /* The -2 is because in C the last character in any string of length n is "\0" - so we only have n-1 characters in the array we can write to. Make -2 instead of -1 to be a bit more sure! */
    int patch_no = infectee->patch_no;

    if((strlen(output->phylogenetics_output_string[patch_no])+strlen(temp_string))>(PHYLO_OUTPUT_STRING_LENGTH-2)){
        write_phylo_transmission_data(file_data_store, output->phylogenetics_output_string[patch_no], patch_no);
        /* Empty output->phylogenetics_output_string. To do this we just need to set the first character to be '\0'. */
        (output->phylogenetics_output_string[patch_no])[0] = '\0';
        // DEBUG - checks that string length is reset to zero.
        //printf("New length = %lu\n",strlen(output->phylogenetics_output_string));
        //printf("Error - need to increase size of PHYLO_OUTPUT_STRING_LENGTH. Exiting\n");
        //printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        //fflush(stdout);
        //exit(1);
    }
    
    /* Add to existing phylogenetic output string. */

    strcat(output->phylogenetics_output_string[patch_no],temp_string);
    
}


/* For initially drawn HIV+ create phylogenetics output as for function phylogenetic_transmission_output_trm() 
 * but with dummy values for infector (as these are seeded, so no infectors).
 *
 * Output is:
 * INFECTOR_ID (-1 here) INFECTEE_ID TIME INFECTOR_IS_ACUTE (-1 here)
 * e.g. if person 1234 is infected in 1975.0 then the output will be
 * -1 1234 1975.0000 -1. Include file_data_store in case we want to be able to write to file immediately
 * (in case any worries about buffer overflow in  phylogenetics_output_string).  */
void store_phylogenetic_transmission_initial_cases(output_struct *output, parameters *param, individual* infectee, file_struct *file_data_store, int t0, int t_step){
    ////// MEMORY CHECK THIS
    char temp_string[100]; /* Temporary store of data from one transmission event. Note that format of string below means it will not be 40 chars long. */

    long new_infectee_id = infectee -> id;

	// Risk group of infected individual
	char infected_risk_text[2];
	if(infectee->sex_risk == LOW){
		sprintf(infected_risk_text,"L");
	}else if(infectee->sex_risk == MEDIUM){
		sprintf(infected_risk_text,"M");
	}else if(infectee->sex_risk == HIGH){
		sprintf(infected_risk_text,"H");
	}
	
    /* Format output. If more data is added, make temp_string a bigger array.
     * The "-1" indicates that this is a seeded infection (so no infector in the model). */
    sprintf(temp_string,"-1,%li,%6.4lg,%i,%i,%i,-1,-1,-1,,,,,%s,-1,%.2lf,-1\n",
		new_infectee_id,infectee->t_sc, t0, t_step,-1,infected_risk_text,infectee->DoB);
	
    /* Add to existing phylogenetic output string. */
    int patch_no = infectee->patch_no;
    strcat(output->phylogenetics_output_string[patch_no],temp_string);
}

void blank_phylo_transmission_data_file(file_struct *file_data_store){
	for(int p=0;p<NPATCHES;p++){
    	file_data_store->PHYLOGENETIC_TRANSMISSION_FILE[p] = fopen(file_data_store->filename_phylogenetic_transmission[p],"w");
    	fprintf(file_data_store->PHYLOGENETIC_TRANSMISSION_FILE[p],"IdInfector,IdInfected,TimeOfInfection,YearOfInfection,TimestepOfInfection,IsInfectorAcute,PartnerARTStatus,IsInfectorOutsidePatch,InfectorCD4,InfectorSPVL,InfectedSPVL,Infector_NPartners,InfectorGender,InfectedRiskGroup,InfectorRiskGroup,InfectedDoB,InfectorDoB,InfectorDRstate,InfectedDRstate,InfectorCascadeRnd,InfectedCascadeRnd\n");
    	fclose(file_data_store->PHYLOGENETIC_TRANSMISSION_FILE[p]);
	}
}


void write_phylo_transmission_data(file_struct *file_data_store, char *phylogenetics_output_string, int patch_no){
    file_data_store->PHYLOGENETIC_TRANSMISSION_FILE[patch_no] = fopen(file_data_store->filename_phylogenetic_transmission[patch_no],"a");
    fprintf(file_data_store->PHYLOGENETIC_TRANSMISSION_FILE[patch_no],"%s",phylogenetics_output_string);
    fclose(file_data_store->PHYLOGENETIC_TRANSMISSION_FILE[patch_no]);
}

/* Prints csv file of relevant demographic information for all individuals in population. */
void write_phylo_individual_data(file_struct *file_data_store, individual *individual_population, long id_counter, int p)
{
    
    char riskstring[20];
    memset(riskstring, '\0', sizeof(riskstring));
    char tempstring[300];
    memset(tempstring, '\0', sizeof(tempstring));
    char PANGEA_STRING[100];
    memset(PANGEA_STRING, '\0', sizeof(PANGEA_STRING));
    long n_id;
    //printf("Phylo individual filename = %s\n",file_data_store->filename_phylogenetic_individualdata);

    file_data_store->PHYLOGENETIC_INDIVIDUALDATA_FILE[p] = fopen(
            file_data_store->filename_phylogenetic_individualdata[p],"w");
    
    fprintf(file_data_store->PHYLOGENETIC_INDIVIDUALDATA_FILE[p],
        "Id,Sex,DoB,DoD,HIV_pos,DRstate,CascadeRnd,t_HIVpos_diagnosis,t_lastART_start,RiskGp,t_diagnosed,cd4_diagnosis,cd4atfirstART,t_1stARTstart,t_1stVLsupp_start,t_1stVLsupp_stop\n");

    for (n_id=0; n_id<id_counter; n_id++){
        if (individual_population[n_id].sex_risk==LOW)
            sprintf(riskstring,"L,");
        else if (individual_population[n_id].sex_risk==MEDIUM)
            sprintf(riskstring,"M,");
        else if (individual_population[n_id].sex_risk==HIGH)
            sprintf(riskstring,"H,");
        else{
            printf("Unknown Sexual Risk Group\n");
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }

        if (individual_population[n_id].gender==MALE)
            sprintf(tempstring,"%li,M,%.2lf,%.2lf,%i,%i,%i,%.2f,%.2f,",individual_population[n_id].id,individual_population[n_id].DoB,individual_population[n_id].DoD,individual_population[n_id].HIV_status>0,
            individual_population[n_id].drug_resistant,individual_population[n_id].cascade_round,individual_population[n_id].t_HIVpos_diag,individual_population[n_id].last_start_art);
        else if (individual_population[n_id].gender==FEMALE)
            sprintf(tempstring,"%li,F,%.2lf,%.2lf,%i,%i,%i,%.2f,%.2f,",individual_population[n_id].id,individual_population[n_id].DoB,individual_population[n_id].DoD,individual_population[n_id].HIV_status>0,
            individual_population[n_id].drug_resistant,individual_population[n_id].cascade_round,individual_population[n_id].t_HIVpos_diag,individual_population[n_id].last_start_art);

        join_strings_with_check(tempstring, riskstring, 300, "tempstring and riskstring in write_phylo_individual_data()");

        /* ND = not diagnosed (ie never had an HIV+ test). */ 
        if (individual_population[n_id].PANGEA_t_diag==-1){
            sprintf(PANGEA_STRING,"ND,%.2f,%.2f,%.2f,%.2f,%.2f",individual_population[n_id].PANGEA_cd4atdiagnosis,individual_population[n_id].PANGEA_cd4atfirstART,
                    individual_population[n_id].PANGEA_date_firstARTstart,individual_population[n_id].PANGEA_date_startfirstVLsuppression,
                    individual_population[n_id].PANGEA_date_endfirstVLsuppression);
        }
        else{
            /* Record date at diagnosis if HIV+: */
            /* Also check that date of end of viral suppression is not after date die (as explained in virally_suppressed_process() in hiv.c): */
            if ((individual_population[n_id].DoD==-1) || (individual_population[n_id].PANGEA_date_endfirstVLsuppression<individual_population[n_id].DoD)){
                sprintf(PANGEA_STRING,"%.2f,%.2f,%.2f,%.2f,%.2f,%.2f",individual_population[n_id].PANGEA_t_diag,individual_population[n_id].PANGEA_cd4atdiagnosis,individual_population[n_id].PANGEA_cd4atfirstART,
                        individual_population[n_id].PANGEA_date_firstARTstart,individual_population[n_id].PANGEA_date_startfirstVLsuppression,
                        individual_population[n_id].PANGEA_date_endfirstVLsuppression);
            }
            else{
                sprintf(PANGEA_STRING,"%.2f,%.2f,%.2f,%.2f,%.2f,-1",individual_population[n_id].PANGEA_t_diag,individual_population[n_id].PANGEA_cd4atdiagnosis,individual_population[n_id].PANGEA_cd4atfirstART,
                        individual_population[n_id].PANGEA_date_firstARTstart,individual_population[n_id].PANGEA_date_startfirstVLsuppression);
            }
        }

        join_strings_with_check(tempstring, PANGEA_STRING, 300, "tempstring and PANGEA_STRING in write_phylo_individual_data()");


        /* If need to record VMMC status: 
        if (individual_population[n_id].gender==MALE){
            if (individual_population[n_id].circ==1)
                strcat(tempstring,"Y\n");
            else
                strcat(tempstring,"N\n");
        }
        else{

        }
         */

        strcat(tempstring,"\n");

        fprintf(file_data_store->PHYLOGENETIC_INDIVIDUALDATA_FILE[p],"%s",tempstring);

    }

    fclose(file_data_store->PHYLOGENETIC_INDIVIDUALDATA_FILE[p]);
}





/* Prints csv file of relevant demographic information for all HIV+ individuals in population to allow computation of life expectancy on/off ART. */
void write_hivpos_individual_data(file_struct *file_data_store, individual *individual_population, long id_counter, int p)
{

    char riskstring[20];
    memset(riskstring, '\0', sizeof(riskstring));
    char tempstring[300];
    memset(tempstring, '\0', sizeof(tempstring));
    char HIVSURVIVAL_STRING[100];
    memset(HIVSURVIVAL_STRING, '\0', sizeof(HIVSURVIVAL_STRING));

    long n_id;
    printf("HIV survival individual filename = %s\n",file_data_store->filename_hivsurvival_individualdata[p]);

    file_data_store->HIVSURVIVAL_INDIVIDUALDATA_FILE[p] = fopen(file_data_store->filename_hivsurvival_individualdata[p],"w");
    fprintf(file_data_store->HIVSURVIVAL_INDIVIDUALDATA_FILE[p],"Id,Sex,DoB,DoD,HIV_pos,RiskGp,t_diagnosed,cd4_diagnosis,cd4atfirstART,t_1stARTstart,t_1stVLsupp_start,t_1stVLsupp_stop,SPVL\n");

    for (n_id=0; n_id<id_counter; n_id++){
        //if (individual_population[n_id].HIV_status>UNINFECTED){
        if (individual_population[n_id].sex_risk==LOW)
            sprintf(riskstring,"L,");
        else if (individual_population[n_id].sex_risk==MEDIUM)
            sprintf(riskstring,"M,");
        else if (individual_population[n_id].sex_risk==HIGH)
            sprintf(riskstring,"H,");
        else{
            printf("Unknown Sexual Risk Group\n");
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }

        if (individual_population[n_id].gender==MALE)
            sprintf(tempstring,"%li,M,%.2lf,%.2lf,%i,",individual_population[n_id].id,individual_population[n_id].DoB,individual_population[n_id].DoD,individual_population[n_id].HIV_status>0);
        else if (individual_population[n_id].gender==FEMALE)
            sprintf(tempstring,"%li,F,%.2lf,%.2lf,%i,",individual_population[n_id].id,individual_population[n_id].DoB,individual_population[n_id].DoD,individual_population[n_id].HIV_status>0);

        join_strings_with_check(tempstring, riskstring, 300, "tempstring and riskstring in write_hivpos_individual_data()");

        /* ND = not diagnosed (ie never had an HIV+ test). */
        if (individual_population[n_id].PANGEA_t_diag==-1){
            sprintf(HIVSURVIVAL_STRING,"ND,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f",individual_population[n_id].PANGEA_cd4atdiagnosis,individual_population[n_id].PANGEA_cd4atfirstART,
                    individual_population[n_id].PANGEA_date_firstARTstart,individual_population[n_id].PANGEA_date_startfirstVLsuppression,
                    individual_population[n_id].PANGEA_date_endfirstVLsuppression,individual_population[n_id].SPVL_num_G+individual_population[n_id].SPVL_num_E);
        }
        else{
            /* Record date at diagnosis if HIV+: */
            /* Also check that date of end of viral suppression is not after date die (as explained in virally_suppressed_process() in hiv.c): */
            if ((individual_population[n_id].DoD==-1) || (individual_population[n_id].PANGEA_date_endfirstVLsuppression<individual_population[n_id].DoD)){
                sprintf(HIVSURVIVAL_STRING,"%.2f,%.2f,%.2f,%.2f,%.2f,%.2f,%.2f",individual_population[n_id].PANGEA_t_diag,individual_population[n_id].PANGEA_cd4atdiagnosis,individual_population[n_id].PANGEA_cd4atfirstART,
                        individual_population[n_id].PANGEA_date_firstARTstart,individual_population[n_id].PANGEA_date_startfirstVLsuppression,
                        individual_population[n_id].PANGEA_date_endfirstVLsuppression,individual_population[n_id].SPVL_num_G+individual_population[n_id].SPVL_num_E);
            }
            else{
                sprintf(HIVSURVIVAL_STRING,"%.2f,%.2f,%.2f,%.2f,%.2f,-1,%.2f",individual_population[n_id].PANGEA_t_diag,individual_population[n_id].PANGEA_cd4atdiagnosis,individual_population[n_id].PANGEA_cd4atfirstART,
                        individual_population[n_id].PANGEA_date_firstARTstart,individual_population[n_id].PANGEA_date_startfirstVLsuppression,individual_population[n_id].SPVL_num_G+individual_population[n_id].SPVL_num_E);
            }
        }

        join_strings_with_check(tempstring, HIVSURVIVAL_STRING, 300, "tempstring and HIVSURVIVAL_STRING in write_hivpos_individual_data()");


        /* If need to record VMMC status:
        if (individual_population[n_id].gender==MALE){
            if (individual_population[n_id].circ==1)
                strcat(tempstring,"Y\n");
            else
                strcat(tempstring,"N\n");
        }
        else{

        }
         */

        strcat(tempstring,"\n");

        fprintf(file_data_store->HIVSURVIVAL_INDIVIDUALDATA_FILE[p],"%s",tempstring);
    }
//  }

    fclose(file_data_store->HIVSURVIVAL_INDIVIDUALDATA_FILE[p]);
}



void print_partnership_network(file_struct *file_data_store, char *output_file_directory, file_label_struct *file_labels,  patch_struct *patch,  double year, int p){
    long n_id, gender;
    float ageid, agepart;
    int n_partners, i_partner;
    long partner_id;
    int partner_patch;
    double duration;
    double begin;

    long id_counter;
    individual *individual_population;
    FILE *PARTNERSHIP_NETWORK_OUTFILE;
    char partnership_network_outfilename[LONGSTRINGLENGTH];
    make_filenames_for_snapshot(partnership_network_outfilename, output_file_directory, file_labels, year, p, "Partnership_network");
    //char temp[100]; /* Temporary store to convert numbers etc. */

    PARTNERSHIP_NETWORK_OUTFILE = fopen(partnership_network_outfilename,"w");
    if (PARTNERSHIP_NETWORK_OUTFILE==NULL){
        printf("Cannot open PARTNERSHIP_NETWORK_OUTFILE\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    fprintf(PARTNERSHIP_NETWORK_OUTFILE, "n_id,partner_id,id_patch,partner_patch,duration,begin,DoB_1,DoB_2\n");
    int patchno=0;
    for (patchno=0;patchno<2;patchno++){
        individual_population=patch[patchno].individual_population; 
        id_counter=patch[patchno].id_counter;
        for (n_id=0; n_id<id_counter; n_id++){
            /* Check that the person is not dead: */
            if (individual_population[n_id].cd4!=DEAD){

                gender = individual_population[n_id].gender;

                n_partners = individual_population[n_id].n_partners;

                ageid = individual_population[n_id].DoB;
                for(i_partner=0;i_partner<n_partners;i_partner++){

                    partner_id = individual_population[n_id].partner_pairs[i_partner]->ptr[1-gender]->id;
                    partner_patch = individual_population[n_id].partner_pairs[i_partner]->ptr[1-gender]->patch_no;
                    agepart = individual_population[n_id].partner_pairs[i_partner]->ptr[1-gender]->DoB;

                    duration = individual_population[n_id].partner_pairs[i_partner]->duration_in_time_steps * TIME_STEP;
                    begin = individual_population[n_id].partner_pairs[i_partner]->begin;

                    if (gender==MALE){
                            fprintf(PARTNERSHIP_NETWORK_OUTFILE, "%li,%li,%i,%i,%6.4f,%6.4f,%.4f,%.4f\n",n_id,partner_id,individual_population[n_id].patch_no,partner_patch,duration,begin,ageid,agepart);
                    }                
                    //if (partner_id>=n_id){
                        //fprintf("%li %li %i %6.4f\n",n_id,partner_id,partner_patch==p,duration);
                        //fprintf(PARTNERSHIP_NETWORK_OUTFILE,"%li %li %i %6.4f\n",n_id,partner_id,partner_patch==p,duration);
                        //if (individual_population[n_id].patch_no==partner_patch){
                        //    fprintf(PARTNERSHIP_NETWORK_OUTFILE,"%li %li %i %6.4f\n",n_id,partner_id,partner_patch==p,duration);
                        //}
                    
                }
            }
        }
    }

    fclose(PARTNERSHIP_NETWORK_OUTFILE);
}



/* Count the number of partnerships at a given time outside the community by gender x risk (and the total number of partnerships). */
void print_partners_outside_community(char *output_file_directory, individual *individual_population, long id_counter, int year, int p){ // HERE could add an option to print only serodiscordant partners
    long n_id, gender, risk;
    int n_partners, i_partner;
    long partner_id;
    int partner_patch;

    /* Use if we want to write to file: */
    FILE *partnership_outfile;
    char partnership_outfilename[LONGSTRINGLENGTH];

    char temp[100]; /* Temporary store to convert numbers etc. */

    memset(partnership_outfilename, '\0', sizeof(partnership_outfilename));
    strncpy(partnership_outfilename,output_file_directory,LONGSTRINGLENGTH);
    add_slash(partnership_outfilename); /* Adds a / or \ as needed if working in directory other than current local dir. */
    strcat(partnership_outfilename,"Partner_outside_inside");
    sprintf(temp,"_patch%i.csv",p);
    strcat(partnership_outfilename,temp);
    partnership_outfile = fopen(partnership_outfilename,"a");
    if (partnership_outfile==NULL){
        printf("Cannot open partnership_outfile\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }

    long n_partner_in_different_patches[N_GENDER][N_RISK];
    long n_partner_in_different_patches_not_stratified = 0;
    double n_partner_total[N_GENDER][N_RISK];    /* Total number of partnerships. */
    double n_partner_total_not_stratified = 0;    /* Total number of partnerships. */
    for (gender=0;gender<N_GENDER;gender++){
        for (risk=0;risk<N_RISK;risk++){
            n_partner_in_different_patches[gender][risk] = 0;
            n_partner_total[gender][risk] = 0;
        }
    }

    /*if(year == 1901)
        printf("----- Year = %d -----\n",year);*/

    for (n_id=0; n_id<id_counter; n_id++){
        /* Check that the person is not dead: */
        if (individual_population[n_id].cd4!=DEAD){

            gender = individual_population[n_id].gender;
            risk = individual_population[n_id].sex_risk;
            n_partners = individual_population[n_id].n_partners;

            for(i_partner=0;i_partner<n_partners;i_partner++){
                partner_id = individual_population[n_id].partner_pairs[i_partner]->ptr[1-gender]->id;
                partner_patch = individual_population[n_id].partner_pairs[i_partner]->ptr[1-gender]->patch_no;

                if (partner_patch==p){
                    n_partner_total[gender][risk] ++; /* NOT double counting as this is from the perspective of the man or the woman only */
                    n_partner_total_not_stratified += 0.5; /* Ensure we only count each partnership once as now we are looking overall */
                    /*if(year == 1901)
                    {
                        printf("Partnership between %li and %li\n",individual_population[n_id].id, partner_id);
                        fflush(stdout);
                    }*/
                }
                else if (partner_patch!=p){
                    n_partner_total[gender][risk]++;
                    n_partner_total_not_stratified ++;
                    n_partner_in_different_patches[gender][risk]++;
                    n_partner_in_different_patches_not_stratified ++;
                }
            }
        }
    }
    fprintf(partnership_outfile,"%i,",year);
    for (gender=0;gender<N_GENDER;gender++)
        for (risk=0;risk<N_RISK;risk++)
            fprintf(partnership_outfile,"%li,",n_partner_in_different_patches[gender][risk]);
    fprintf(partnership_outfile,"%li,",n_partner_in_different_patches_not_stratified);
    for (gender=0;gender<N_GENDER;gender++)
        for (risk=0;risk<N_RISK;risk++)
            fprintf(partnership_outfile,"%lg,",n_partner_total[gender][risk]);
    fprintf(partnership_outfile,"%lg,",n_partner_total_not_stratified);
    for (gender=0;gender<N_GENDER;gender++)
        for (risk=0;risk<N_RISK;risk++)
            fprintf(partnership_outfile,"%6.4f,",n_partner_in_different_patches[gender][risk]/(1.0*n_partner_total[gender][risk]));
    fprintf(partnership_outfile,"%6.4f",n_partner_in_different_patches_not_stratified/(1.0*n_partner_total_not_stratified));

    fprintf(partnership_outfile,"\n");

    //  fprintf(partnership_outfile,"t=%i ",year);
    //  for (gender=0;gender<N_GENDER;gender++)
    //      for (risk=0;risk<N_RISK;risk++)
    //          fprintf(partnership_outfile,"%li ",n_partner_in_different_patches[gender][risk]);
    //  for (gender=0;gender<N_GENDER;gender++)
    //      for (risk=0;risk<N_RISK;risk++)
    //          fprintf(partnership_outfile,"%li ",n_partner_total[gender][risk]);
    //  for (gender=0;gender<N_GENDER;gender++)
    //      for (risk=0;risk<N_RISK;risk++)
    //          fprintf(partnership_outfile,"%6.4f ",n_partner_in_different_patches[gender][risk]/(1.0*n_partner_total[gender][risk]));

    fclose(partnership_outfile);
}

/* Count the number of partnerships at a given time outside the community by gender x risk (and the total number of partnerships). */
void initialise_partners_outside_community_file(char *output_file_directory, int p){

    FILE *partnership_outfile;
    char partnership_outfilename[LONGSTRINGLENGTH];

    char temp[100]; /* Temporary store to convert numbers etc. */

    memset(partnership_outfilename, '\0', sizeof(partnership_outfilename));
    strncpy(partnership_outfilename,output_file_directory,LONGSTRINGLENGTH);
    add_slash(partnership_outfilename); /* Adds a / or \ as needed if working in directory other than current local dir. */
    strcat(partnership_outfilename,"Partner_outside_inside");
    sprintf(temp,"_patch%i.csv",p);
    strcat(partnership_outfilename,temp);
    partnership_outfile = fopen(partnership_outfilename,"w");
    if (partnership_outfile==NULL){
        printf("Cannot open partnership_outfile\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }

    fprintf(partnership_outfile,"Time,");
    fprintf(partnership_outfile,"N_outside_M_low,N_outside_M_med,N_outside_M_high,N_outside_F_low,N_outside_F_med,N_outside_F_high,N_outside_all,");
    fprintf(partnership_outfile,"N_total_M_low,N_total_M_med,N_total_M_high,N_total_F_low,N_total_F_med,N_total_F_high,N_total_all,");
    fprintf(partnership_outfile,"Prop_outside_M_low,Prop_outside_M_med,Prop_outside_M_high,Prop_outside_F_low,Prop_outside_F_med,Prop_outside_F_high,Prop_outside_all\n");
    fclose(partnership_outfile);

}

void print_assortativity(char *output_file_directory, debug_struct *debug, patch_struct *patch, int i_run, file_struct *all_files)
{
    int year, age_f, age_m, risk_f, risk_m;

    /******************************************************/
    /***** Age assortativity at partnership formation *****/
    /******************************************************/

    all_files->age_assortativity = fopen(all_files->filename_age_assortativity,"w");
    if (all_files->age_assortativity==NULL){
        printf("Cannot open age_assortativity file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    fprintf(all_files->age_assortativity,"year,");
    for(age_f=0 ; age_f<N_AGE ; age_f++)
    {
        for(age_m=0 ; age_m<N_AGE ; age_m++)
        {
            fprintf(all_files->age_assortativity,"age_of_partners_at_partnership_formation[age_f_%d][age_m_%d]",age_f,age_m);
            if(age_f<N_AGE-1 || age_m<N_AGE-1)
                fprintf(all_files->age_assortativity,",");
        }
    }
    fprintf(all_files->age_assortativity,"\n");


    for (year=patch[0].param->start_time_simul; year<patch[0].param->end_time_simul; year++)
    {
        fprintf(all_files->age_assortativity,"%d,",year);
        for(age_f=0 ; age_f<N_AGE ; age_f++)
        {
            for(age_m=0 ; age_m<N_AGE ; age_m++)
            {
                fprintf(all_files->age_assortativity,"%ld",debug->age_of_partners_at_partnership_formation[year - patch[0].param->start_time_simul][age_f][age_m]);
                if(age_f<N_AGE-1 || age_m<N_AGE-1)
                    fprintf(all_files->age_assortativity,",");
            }
        }
        fprintf(all_files->age_assortativity,"\n");
    }
    fclose(all_files->age_assortativity);

    /******************************************************/
    /***** Risk assortativity at partnership formation *****/
    /******************************************************/

    all_files->risk_assortativity = fopen(all_files->filename_risk_assortativity,"w");
    if (all_files->risk_assortativity==NULL){
        printf("Cannot open risk_assortativity file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    fprintf(all_files->risk_assortativity,"year,");
    for(risk_f=0 ; risk_f<N_RISK ; risk_f++)
    {
        for(risk_m=0 ; risk_m<N_RISK ; risk_m++)
        {
            fprintf(all_files->risk_assortativity,"risk_of_partners_at_partnership_formation[risk_f_%d][risk_m_%d]",risk_f,risk_m);
            if(risk_f<N_RISK-1 || risk_m<N_RISK-1)
                fprintf(all_files->risk_assortativity,",");
        }
    }
    fprintf(all_files->risk_assortativity,"\n");


    for (year=patch[0].param->start_time_simul; year<patch[0].param->end_time_simul; year++)
    {
        fprintf(all_files->risk_assortativity,"%d,",year);
        for(risk_f=0 ; risk_f<N_RISK ; risk_f++)
        {
            for(risk_m=0 ; risk_m<N_RISK ; risk_m++)
            {
                fprintf(all_files->risk_assortativity,"%ld",debug->risk_of_partners_at_partnership_formation[year - patch[0].param->start_time_simul][risk_f][risk_m]);
                if(risk_f<N_RISK-1 || risk_m<N_RISK-1)
                    fprintf(all_files->risk_assortativity,",");
            }
        }
        fprintf(all_files->risk_assortativity,"\n");
    }
    fclose(all_files->risk_assortativity);

    /******************************************************/
    /***** Age assortativity cross sectional *****/
    /******************************************************/

    all_files->age_assortativity_cross_sectional = fopen(all_files->filename_age_assortativity_cross_sectional,"w");
    if (all_files->age_assortativity_cross_sectional==NULL){
        printf("Cannot open age_assortativity_cross_sectional file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    fprintf(all_files->age_assortativity_cross_sectional,"year,");
    for(age_f=0 ; age_f<N_AGE ; age_f++)
    {
        for(age_m=0 ; age_m<N_AGE ; age_m++)
        {
            fprintf(all_files->age_assortativity_cross_sectional,"age_of_partners_cross_sectional[age_f_%d][age_m_%d]",age_f,age_m);
            if(age_f<N_AGE-1 || age_m<N_AGE-1)
                fprintf(all_files->age_assortativity_cross_sectional,",");
        }
    }
    fprintf(all_files->age_assortativity_cross_sectional,"\n");


    for (year=patch[0].param->start_time_simul; year<patch[0].param->end_time_simul; year++)
    {
        fprintf(all_files->age_assortativity_cross_sectional,"%d,",year);
        for(age_f=0 ; age_f<N_AGE ; age_f++)
        {
            for(age_m=0 ; age_m<N_AGE ; age_m++)
            {
                fprintf(all_files->age_assortativity_cross_sectional,"%lg",debug->age_of_partners_cross_sectional[year - patch[0].param->start_time_simul][age_f][age_m]);
                if(age_f<N_AGE-1 || age_m<N_AGE-1)
                    fprintf(all_files->age_assortativity_cross_sectional,",");
            }
        }
        fprintf(all_files->age_assortativity_cross_sectional,"\n");
    }
    fclose(all_files->age_assortativity_cross_sectional);

    /******************************************************/
    /***** Risk assortativity cross sectional *****/
    /******************************************************/

    all_files->risk_assortativity_cross_sectional = fopen(all_files->filename_risk_assortativity_cross_sectional,"w");
    if (all_files->risk_assortativity_cross_sectional==NULL){
        printf("Cannot open risk_assortativity_cross_sectional file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    fprintf(all_files->risk_assortativity_cross_sectional,"year,");
    for(risk_f=0 ; risk_f<N_RISK ; risk_f++)
    {
        for(risk_m=0 ; risk_m<N_RISK ; risk_m++)
        {
            fprintf(all_files->risk_assortativity_cross_sectional,"risk_of_partners_cross_sectional[risk_f_%d][risk_m_%d]",risk_f,risk_m);
            if(risk_f<N_RISK-1 || risk_m<N_RISK-1)
                fprintf(all_files->risk_assortativity_cross_sectional,",");
        }
    }
    fprintf(all_files->risk_assortativity_cross_sectional,"\n");


    for (year=patch[0].param->start_time_simul; year<patch[0].param->end_time_simul; year++)
    {
        fprintf(all_files->risk_assortativity_cross_sectional,"%d,",year);
        for(risk_f=0 ; risk_f<N_RISK ; risk_f++)
        {
            for(risk_m=0 ; risk_m<N_RISK ; risk_m++)
            {
                fprintf(all_files->risk_assortativity_cross_sectional,"%lg",debug->risk_of_partners_cross_sectional[year - patch[0].param->start_time_simul][risk_f][risk_m]);
                if(risk_f<N_RISK-1 || risk_m<N_RISK-1)
                    fprintf(all_files->risk_assortativity_cross_sectional,",");
            }
        }
        fprintf(all_files->risk_assortativity_cross_sectional,"\n");
    }
    fclose(all_files->risk_assortativity_cross_sectional);
}

void sweep_through_all_and_compute_distribution_lifetime_and_lastyear_partners(patch_struct *patch, all_partnerships * overall_partnerships, int t0, int t_step, output_struct *output)
{
    int p, k, g, a, r;
    individual temp_ind;
    int age_gp;

    for(int p=0 ; p<NPATCHES; p++)
    {
        /* initialising to zero */
        for(g=0 ; g<N_GENDER; g++)
        {
            for(a=0 ; a<N_AGE; a++)
            {
                for(r=0 ; r<N_RISK; r++)
                {
                    for (k=0; k<=MAX_N_PARTNERS_IN_OUTPUTS; k++)
                    {
                        patch[p].cross_sectional_distr_n_lifetime_partners[g][a][r][k] = 0;
                        patch[p].cross_sectional_distr_n_partners_lastyear[g][a][r][k] = 0;
                    }
                }
            }
        }

        /* filling in */
        for(k=0 ; k<patch[p].id_counter; k++)
        {
            temp_ind = patch[p].individual_population[k];

            if(temp_ind.cd4 > DEAD) // only count if person still alive
            {

                age_gp =  get_age_group(temp_ind.DoB,t0+t_step*TIME_STEP, AGE_GROUPS, N_AGE);

                if(temp_ind.id==FOLLOW_INDIVIDUAL  && p==FOLLOW_PATCH)
                {
                    print_individual(&temp_ind);
                }

                if(temp_ind.n_lifetime_partners<=MAX_N_PARTNERS_IN_OUTPUTS)
                    patch[p].cross_sectional_distr_n_lifetime_partners[temp_ind.gender][age_gp][temp_ind.sex_risk][temp_ind.n_lifetime_partners]++;
                else
                    patch[p].cross_sectional_distr_n_lifetime_partners[temp_ind.gender][age_gp][temp_ind.sex_risk][MAX_N_PARTNERS_IN_OUTPUTS]++;

                if(temp_ind.n_partnersminusoneyear + temp_ind.n_lifetime_partners - temp_ind.n_lifetimeminusoneyear_partners<=MAX_N_PARTNERS_IN_OUTPUTS)
                    patch[p].cross_sectional_distr_n_partners_lastyear[temp_ind.gender][age_gp][temp_ind.sex_risk][temp_ind.n_partnersminusoneyear + temp_ind.n_lifetime_partners - temp_ind.n_lifetimeminusoneyear_partners]++;
                else
                    patch[p].cross_sectional_distr_n_partners_lastyear[temp_ind.gender][age_gp][temp_ind.sex_risk][MAX_N_PARTNERS_IN_OUTPUTS]++;
            }
        }
    }
}

void write_distr_n_lifetime_partners_and_n_partners_lastyear(patch_struct *patch, file_struct *file_data_store)
{
    int p, g, a, r, k;
    char gchar;

    for(p=0 ; p<NPATCHES ; p++)
    {

        file_data_store->distr_n_lifetime_partners[p] = fopen(file_data_store->filename_distr_n_lifetime_partners[p],"w");
        if (file_data_store->distr_n_lifetime_partners[p]==NULL){
            printf("Cannot open distr_n_lifetime_partners file\n");
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }

        file_data_store->distr_n_partners_lastyear[p] = fopen(file_data_store->filename_distr_n_partners_lastyear[p],"w");
        if (file_data_store->distr_n_partners_lastyear[p]==NULL){
            printf("Cannot open distr_n_partners_lastyear file\n");
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }

        fprintf(file_data_store->distr_n_lifetime_partners[p],"n_lifetime_partners,");
        fprintf(file_data_store->distr_n_partners_lastyear[p],"n_partners_lastyear,");
        for (g=0; g<N_GENDER; g++)
        {
            if(g==MALE)
                gchar='M';
            else
                gchar='F';
            for (a=0; a<N_AGE; a++)
            {
                for (r=0; r<N_RISK; r++)
                {
                    if(g==N_GENDER-1 && a==N_AGE-1 && r==N_RISK-1)
                    {
                        fprintf(file_data_store->distr_n_lifetime_partners[p],"%ca%dr%d",gchar,a,r);
                        fprintf(file_data_store->distr_n_partners_lastyear[p],"%ca%dr%d",gchar,a,r);
                    }
                    else
                    {
                        fprintf(file_data_store->distr_n_lifetime_partners[p],"%ca%dr%d,",gchar,a,r);
                        fprintf(file_data_store->distr_n_partners_lastyear[p],"%ca%dr%d,",gchar,a,r);
                    }
                }
            }
        }
        fprintf(file_data_store->distr_n_lifetime_partners[p],"\n");
        fprintf(file_data_store->distr_n_partners_lastyear[p],"\n");

        for(k=0; k<=MAX_N_PARTNERS_IN_OUTPUTS ; k++)
        {
            fprintf(file_data_store->distr_n_lifetime_partners[p],"%d,",k);
            fprintf(file_data_store->distr_n_partners_lastyear[p],"%d,",k);
            for (g=0; g<N_GENDER; g++)
            {
                for (a=0; a<N_AGE; a++)
                {
                    for (r=0; r<N_RISK; r++)
                    {
                        if(g==N_GENDER-1 && a==N_AGE-1 && r==N_RISK-1)
                        {
                            fprintf(file_data_store->distr_n_lifetime_partners[p],"%ld",patch[p].cross_sectional_distr_n_lifetime_partners[g][a][r][k]);
                            fprintf(file_data_store->distr_n_partners_lastyear[p],"%ld",patch[p].cross_sectional_distr_n_partners_lastyear[g][a][r][k]);
                        }
                        else
                        {
                            fprintf(file_data_store->distr_n_lifetime_partners[p],"%ld,",patch[p].cross_sectional_distr_n_lifetime_partners[g][a][r][k]);
                            fprintf(file_data_store->distr_n_partners_lastyear[p],"%ld,",patch[p].cross_sectional_distr_n_partners_lastyear[g][a][r][k]);

                        }
                    }
                }
            }
            fprintf(file_data_store->distr_n_lifetime_partners[p],"\n");
            fprintf(file_data_store->distr_n_partners_lastyear[p],"\n");
        }

        fclose(file_data_store->distr_n_lifetime_partners[p]);
        fclose(file_data_store->distr_n_partners_lastyear[p]);

    }
}



void write_pc_data(patch_struct *patch, int p, file_struct *file_data_store){
    //int pc_enrolment_round= 0; /* Set for now to allow us to add in PC12N/PC24N later. */
    int pc_round;
    int ap, g, age_entering_cohort;
    int n;
    individual *this_person;  /* Acts as a pointer to an already created person (so makes code more readable) - no need to malloc. */

    int Ncohort[N_GENDER][AGE_PC_MAX-AGE_PC_MIN+1];
    int Nhivpos[N_GENDER][AGE_PC_MAX-AGE_PC_MIN+1];
    int NonART[N_GENDER][AGE_PC_MAX-AGE_PC_MIN+1];
    int NVS[N_GENDER][AGE_PC_MAX-AGE_PC_MIN+1];
    int Nsd; /* Number in serodiscordant partnership. Not stratified as use for validation. */

    file_data_store->PC_DATAFILE[p] = fopen(file_data_store->filename_PC_data[p],"w");
    if (file_data_store->PC_DATAFILE[p]==NULL){
        printf("Cannot open PC_datafile file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }

    /* Make header for file. */
    fprintf(file_data_store->PC_DATAFILE[p],"PCround,");
    for (g=0; g<N_GENDER; g++)
        for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++){
            if (g==MALE)
                fprintf(file_data_store->PC_DATAFILE[p],"NtotM[%i],",ap+AGE_PC_MIN);
            else
                fprintf(file_data_store->PC_DATAFILE[p],"NtotF[%i],",ap+AGE_PC_MIN);
        }
    for (g=0; g<N_GENDER; g++)
        for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++){
            if (g==MALE)
                fprintf(file_data_store->PC_DATAFILE[p],"NposM[%i],",ap+AGE_PC_MIN);
            else
                fprintf(file_data_store->PC_DATAFILE[p],"NposF[%i],",ap+AGE_PC_MIN);
        }
    for (g=0; g<N_GENDER; g++)
        for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++){
            if (g==MALE)
                fprintf(file_data_store->PC_DATAFILE[p],"NonARTM[%i],",ap+AGE_PC_MIN);
            else
                fprintf(file_data_store->PC_DATAFILE[p],"NonARTF[%i],",ap+AGE_PC_MIN);
        }
    for (g=0; g<N_GENDER; g++)
        for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++){
            if (g==MALE)
                fprintf(file_data_store->PC_DATAFILE[p],"NvsM[%i],",ap+AGE_PC_MIN);
            else
                fprintf(file_data_store->PC_DATAFILE[p],"NvsF[%i],",ap+AGE_PC_MIN);
        }
    fprintf(file_data_store->PC_DATAFILE[p],"Nsd,");
    fprintf(file_data_store->PC_DATAFILE[p],"\n");

    printf("Cohort size = %i\n",patch[p].param->PC_params->cohort_size);
    //printf("PC filename = %s\n",file_data_store->filename_PC_data[p]);

    for (pc_round=0; pc_round<NPC_ROUNDS; pc_round++){
        for (g=0; g<N_GENDER; g++){
            for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++){
                Ncohort[g][ap] = 0;
                Nhivpos[g][ap] = 0;
                NonART[g][ap] = 0;
                NVS[g][ap] = 0;
            }
        }
        Nsd=0;

        for (n=0; n<patch[p].param->PC_params->cohort_size; n++){
            /* If person was retained then count them here: */
            if (patch[p].PC_cohort_data->PC0_cohort_data[n].RETAINED_IN_COHORT[pc_round]== 1){
                this_person = &(patch[p].individual_population[patch[p].PC_cohort_data->PC0_cohort_data[n].id]);
                //printf("n=%i id = %li %li\n",n,this_person->id,patch[p].PC_cohort_data->PC0_cohort_data[n].id);
                //g = this_person->gender;
                g = patch[p].PC_cohort_data->PC0_cohort_data[n].gender;
                age_entering_cohort = (int) floor(patch[p].param->PC_params->PC_START_YEAR[0] - this_person->DoB);
                if (age_entering_cohort<AGE_PC_MIN || age_entering_cohort >AGE_PC_MAX){
                    printf("age_entering_cohort = %i DoB=%lf PC start = %i\n",age_entering_cohort,this_person->DoB,patch[p].param->PC_params->PC_START_YEAR[0]);
                    printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
                    fflush(stdout);
                    exit(1);
                }
                //ap = age_entering_cohort - AGE_PC_MIN;
                ap = patch[p].PC_cohort_data->PC0_cohort_data[n].ap;
                Ncohort[g][ap]++;
                if (patch[p].PC_cohort_data->PC0_cohort_data[n].HIV_status[pc_round]<UNINFECTED || patch[p].PC_cohort_data->PC0_cohort_data[n].HIV_status[pc_round]>CHRONIC){
                    printf("UNKNOWN HIV status in PC. Exiting\n");
                    printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
                    fflush(stdout);
                    exit(1);
                }
                if (patch[p].PC_cohort_data->PC0_cohort_data[n].HIV_status[pc_round]>UNINFECTED){
                    Nhivpos[g][ap]++;
                    if (patch[p].PC_cohort_data->PC0_cohort_data[n].ART_status[pc_round]==EARLYART || patch[p].PC_cohort_data->PC0_cohort_data[n].ART_status[pc_round]==LTART_VS || patch[p].PC_cohort_data->PC0_cohort_data[n].ART_status[pc_round]==LTART_VU){
                        NonART[g][ap]++;
                        if (patch[p].PC_cohort_data->PC0_cohort_data[n].ART_status[pc_round]==LTART_VS)
                            NVS[g][ap]++;
                    }
                }
                if (patch[p].PC_cohort_data->PC0_cohort_data[n].HIV_status[pc_round]==UNINFECTED){
                    if (patch[p].PC_cohort_data->PC0_cohort_data[n].serodiscordant_status[pc_round]>=1)
                        Nsd++;
                }
            }

        }
        fprintf(file_data_store->PC_DATAFILE[p],"PC%i,",pc_round*12);
        for (g=0; g<N_GENDER; g++)
            for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++)
                fprintf(file_data_store->PC_DATAFILE[p],"%i,",Ncohort[g][ap]);
        for (g=0; g<N_GENDER; g++)
            for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++)
                fprintf(file_data_store->PC_DATAFILE[p],"%i,",Nhivpos[g][ap]);
        for (g=0; g<N_GENDER; g++)
            for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++)
                fprintf(file_data_store->PC_DATAFILE[p],"%i,",NonART[g][ap]);
        for (g=0; g<N_GENDER; g++)
            for (ap=0; ap<(AGE_PC_MAX-AGE_PC_MIN+1); ap++)
                fprintf(file_data_store->PC_DATAFILE[p],"%i,",NVS[g][ap]);
        fprintf(file_data_store->PC_DATAFILE[p],"%i,",Nsd);
        fprintf(file_data_store->PC_DATAFILE[p],"\n");
    }

    fclose(file_data_store->PC_DATAFILE[p]);

}



void write_chips_data_visit(patch_struct *patch, int p, file_struct *file_data_store, output_struct *output)
{
    int g,ac, chips_round;
    file_data_store->ChipsVisit_DATAFILE[p] = fopen(file_data_store->filename_chipsvisit_data[p],"w");
    if (file_data_store->ChipsVisit_DATAFILE[p]==NULL){
        printf("Cannot open ChipsVisit_DATAFILE file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }

    /* Make header for file. */
    fprintf(file_data_store->ChipsVisit_DATAFILE[p],"CHIPSROUND,");
    for (g=0; g<N_GENDER; g++)
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            if (g==MALE)
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NtotM[%i],",ac+AGE_CHIPS);
            else
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NtotF[%i],",ac+AGE_CHIPS);
        }
    for (g=0; g<N_GENDER; g++)
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            if (g==MALE)
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NposM[%i],",ac+AGE_CHIPS);
            else
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NposF[%i],",ac+AGE_CHIPS);
        }
    for (g=0; g<N_GENDER; g++)
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            if (g==MALE)
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NawareM[%i],",ac+AGE_CHIPS);
            else
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NawareF[%i],",ac+AGE_CHIPS);
        }
    for (g=0; g<N_GENDER; g++)
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            if (g==MALE)
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NonARTM[%i],",ac+AGE_CHIPS);
            else
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NonARTF[%i],",ac+AGE_CHIPS);
        }
    for (g=0; g<N_GENDER; g++)
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            if (g==MALE)
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NvsM[%i],",ac+AGE_CHIPS);
            else
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"NvsF[%i],",ac+AGE_CHIPS);
        }
    fprintf(file_data_store->ChipsVisit_DATAFILE[p],"\n");
    
    for (chips_round=0; chips_round<NCHIPSROUNDS; chips_round++){
        fprintf(file_data_store->ChipsVisit_DATAFILE[p],"%i,",chips_round+1);
        for (g=0; g<N_GENDER; g++){
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"%li,",output->NCHIPS_VISITED[p][g][ac][chips_round]);
            }
        }
        for (g=0; g<N_GENDER; g++){
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"%li,",output->NCHIPS_HIVPOS[p][g][ac][chips_round]);
            }
        }
        for (g=0; g<N_GENDER; g++){
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"%li,",output->NCHIPS_HIVAWARE[p][g][ac][chips_round]);
            }
        }
        for (g=0; g<N_GENDER; g++){
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"%li,",output->NCHIPS_ONART[p][g][ac][chips_round]);
            }
        }
        for (g=0; g<N_GENDER; g++){
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                fprintf(file_data_store->ChipsVisit_DATAFILE[p],"%li,",output->NCHIPS_VS[p][g][ac][chips_round]);
            }
        }
        fprintf(file_data_store->ChipsVisit_DATAFILE[p],"\n");
    }
    fclose(file_data_store->ChipsVisit_DATAFILE[p]);
}


/* Write the chips cascade at the start of each year. */
void write_chips_data_annual(patch_struct *patch, int p, int year, int t_step, int POPART_FINISHED, file_struct *file_data_store){

    int g, ac, v;
    long n_id;
    long N_POPULATION[N_GENDER][MAX_AGE-AGE_CHIPS+1]; /* Total population (to get CHiPS coverage). */
    /* Duplicate outputs in output_struct for easy comparison. */
    long NCHIPS_VISITED[N_GENDER][MAX_AGE-AGE_CHIPS+1];
    long NCHIPS_HIVPOS[N_GENDER][MAX_AGE-AGE_CHIPS+1];
    long NCHIPS_HIVAWARE[N_GENDER][MAX_AGE-AGE_CHIPS+1];
    long NCHIPS_ONART[N_GENDER][MAX_AGE-AGE_CHIPS+1];
    long NCHIPS_VS[N_GENDER][MAX_AGE-AGE_CHIPS+1];
    long total_chips_visits = 0;

    /* Fairly arbitrarily, we store the number of people who have been visited 0, 1, 2, 3, 4, 5+ times.The upper limit should
     * be bigger than the 4 visits scheduled in PopART, but in principle this could be more than 5 visits - you just need
     * to change the size of MAXVISITSRECORDED below. */
    int MAXVISITSRECORDED = 5;
    //long *nvisits_distribution[N_GENDER];
    long nvisits_distribution[N_GENDER][6];
    //long **nvisits_distribution;
    //nvisits_distribution = malloc(N_GENDER*sizeof(long *));

    long n_chips_start_art = 0;
    individual *person;            /* Temporary pointer to person currently being used, to make code more readable. As pointing to existing memory no malloc used. */
    int person_age;

    if (year<patch[p].param->CHIPS_START_YEAR[0]){
        printf("Error - called write_chips_data_annual before first CHiPs round. Exiting\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }


    /* Set counters to zero: */
    for (g=0;g<N_GENDER;g++){
        for (ac=0; ac<MAX_AGE-AGE_CHIPS+1; ac++){
            N_POPULATION[g][ac] = 0;
            NCHIPS_VISITED[g][ac] = 0;
            NCHIPS_HIVPOS[g][ac] = 0;
            NCHIPS_HIVAWARE[g][ac] = 0;
            NCHIPS_ONART[g][ac] = 0;
            NCHIPS_VS[g][ac] = 0;
        }

        /* We go from 0..MAXVISITSRECORDED - hence "<=" rather than "<". */
        for (v=0;v<=MAXVISITSRECORDED;v++)
            nvisits_distribution[g][v] = 0;
    }


    int youngest_age_eligible_in_this_chips_round;
    int current_chips_round = get_chips_round(patch[p].param, year, t_step);
    if (POPART_FINISHED==1)
        youngest_age_eligible_in_this_chips_round = AGE_CHIPS;
    else
        youngest_age_eligible_in_this_chips_round = AGE_CHIPS + (year-patch[p].param->CHIPS_START_YEAR[current_chips_round]);
    //printf("time = %6.4f CHISPAGE=%i\n",year+t_step*TIME_STEP,youngest_age_eligible_in_this_chips_round);
    //fflush(stdout);


    int NDIED = 0;

    for (n_id=0; n_id<patch[p].id_counter; n_id++){
        person = &(patch[p].individual_population[n_id]);
        person_age = (int) floor(year - person->DoB);
        if (person_age>=AGE_CHIPS){
            if ((person->cd4>DEAD) || ((person->cd4==DEAD) && (person->DoD>=patch[p].param->CHIPS_START_YEAR[current_chips_round]))){
                /* Note that there is a slight issue that people may be visited successfully by chips, then die
                 * (or be scheduled to receive a visit but die beforehand). To get around this use a special value for
                 * VISITED_BY_CHIPS_THISROUND. */
                if (person->VISITED_BY_CHIPS_THISROUND>DIEDBEFORECHIPSVISIT){
                    g = person->gender;
                    if (person_age<MAX_AGE)
                        ac = person_age - AGE_CHIPS; /* Note that  aa = (int) floor(floor(t) - individual->DoB) - AGE_ADULT; and ac = aa-(AGE_CHIPS-AGE_ADULT); */
                    else
                        ac = MAX_AGE - AGE_CHIPS;
                    N_POPULATION[g][ac]++;
                    if (person->VISITED_BY_CHIPS_THISROUND == TRUE){
                        NCHIPS_VISITED[g][ac]++;
                        if (person->HIV_status>UNINFECTED){
                            NCHIPS_HIVPOS[g][ac]++;
                            if (person->ART_status>=ARTNAIVE && person->ART_status<ARTDEATH){
                                NCHIPS_HIVAWARE[g][ac]++;
                                if (person->ART_status==EARLYART || person->ART_status==LTART_VS || person->ART_status==LTART_VU){
                                    NCHIPS_ONART[g][ac]++;
                                    if (person->ART_status==LTART_VS)
                                        NCHIPS_VS[g][ac]++;
                                }
                            }
                        }
                    }

                    /* Check that VISITED_BY_CHIPS_THISROUND only takes the remaining allowed values {0,1}. */
                    if (person->VISITED_BY_CHIPS_THISROUND!=0 && person->VISITED_BY_CHIPS_THISROUND!=1)
                        printf("Error: at t=%6.4lf person->VISITED_BY_CHIPS_THISROUND=%i person->id=%li person->NCHIPSVISITS = %i\n",year+t_step*TIME_STEP,person->VISITED_BY_CHIPS_THISROUND,person->id,person->NCHIPSVISITS);


                    /* v is the lifetime number of visits this individual has had by CHiPs. */
                    v = person->NCHIPSVISITS;

                    if (v>=MAXVISITSRECORDED)
                        nvisits_distribution[g][MAXVISITSRECORDED]++;
                    else
                        nvisits_distribution[g][v]++;
                    total_chips_visits += v; /* Use this to calculate mean number of visits per person in CHiPs denominator. */
                    if(person->VISITEDBYCHIPS_TO_INIT_ART)
                        n_chips_start_art++;
                }
                else{
                    NDIED++; /* Not used for now, but keep track in case. */
                }

            }
        }
    }

    /* Make header for file. */
    if (year==patch[p].param->CHIPS_START_YEAR[0]){
        file_data_store->ChipsAnnual_DATAFILE[p] = fopen(file_data_store->filename_chipsannual_data[p],"w");
        if (file_data_store->ChipsAnnual_DATAFILE[p]==NULL){
            printf("Cannot open ChipsAnnual_DATAFILE file\n");
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }

        fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"Year ");
        for (g=0; g<N_GENDER; g++)
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                if (g==MALE)
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NtotM[%i] ",ac+AGE_CHIPS);
                else
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NtotF[%i] ",ac+AGE_CHIPS);
            }
        for (g=0; g<N_GENDER; g++)
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                if (g==MALE)
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NposM[%i] ",ac+AGE_CHIPS);
                else
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NposF[%i] ",ac+AGE_CHIPS);
            }
        for (g=0; g<N_GENDER; g++)
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                if (g==MALE)
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NawareM[%i] ",ac+AGE_CHIPS);
                else
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NawareF[%i] ",ac+AGE_CHIPS);
            }
        for (g=0; g<N_GENDER; g++)
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                if (g==MALE)
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NonARTM[%i] ",ac+AGE_CHIPS);
                else
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NonARTF[%i] ",ac+AGE_CHIPS);
            }
        for (g=0; g<N_GENDER; g++)
            for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
                if (g==MALE)
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NvsM[%i] ",ac+AGE_CHIPS);
                else
                    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"NvsF[%i] ",ac+AGE_CHIPS);
            }

        fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"\n");
    }
    else{
        file_data_store->ChipsAnnual_DATAFILE[p] = fopen(file_data_store->filename_chipsannual_data[p],"a");
        if (file_data_store->ChipsAnnual_DATAFILE[p]==NULL){
            printf("Cannot open ChipsAnnual_DATAFILE file\n");
            printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
            fflush(stdout);
            exit(1);
        }
    }

    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"%i ",year);
    for (g=0; g<N_GENDER; g++){
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"%li ",NCHIPS_VISITED[g][ac]);
        }
    }
    for (g=0; g<N_GENDER; g++){
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"%li ",NCHIPS_HIVPOS[g][ac]);
        }
    }
    for (g=0; g<N_GENDER; g++){
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"%li ",NCHIPS_HIVAWARE[g][ac]);
        }
    }
    for (g=0; g<N_GENDER; g++){
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"%li ",NCHIPS_ONART[g][ac]);
        }
    }
    for (g=0; g<N_GENDER; g++){
        for (ac=0; ac<(MAX_AGE-AGE_CHIPS+1); ac++){
            fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"%li ",NCHIPS_VS[g][ac]);
        }
    }
    fprintf(file_data_store->ChipsAnnual_DATAFILE[p],"\n");

    fclose(file_data_store->ChipsAnnual_DATAFILE[p]);
}


void store_cost_effectiveness_outputs(patch_struct *patch, int p, output_struct *output, 
    all_partnerships *overall_partnerships, int *n_infected_total, int year, int i_run){
    /* Stores annual data associated with the cost effectiveness output (such as incidence,
    prevalence, number on ART, cum. no. of tests etc.) for a single patch (patch `p`) in the output
    structure `output`.  
    
    This function populates a range of string variables (e.g. `temp_string`) with output summaries
    from the different patches.  These strings are then added to the structure `output` which 
    is used within functions which write to file.  Output is only generated for a single year.  
    
    Arguments
    ---------
    patch : pointer to an array of patch_struct structs
        An array of patch structs each of which stores information about a patch (see structures.h
        for attributes of the patch structures).  
    p : int
        The index of the patch for which output is to be generated.  
    output : pointer to an output_struct struct
        Structure within which the strings of output are to be stored.  
    overall_partnerships : pointer to an all_partnerships struct
        
    n_infected_total : pointer to an int
    year : int
        Year in question for which output is to be generated.  
    
    Returns
    -------
    Nothing; output is stored in output_struct
    */
    
    int year_idx = year - patch[p].param->start_time_simul;
    
    int aa, g, r, ai;
    long n_id;
    long npositive_wrong=0;
    long nincident=0;
    long npop_m = 0;
    long npop_f = 0;
    long npop;
    long npop_check = 0;
    long npositive_m=0;
    long npositive_m_cd4[NCD4];
    long npositive_f=0;
    long npositive_f_cd4[NCD4];
    long npositive;
    long npositive_dead = 0;
    long n_dead = 0;
    int i;
    
    long NArt_m = 0;
    long NNeedART_m = 0;
    long NArt_f = 0;
    long NNeedART_f = 0;/* Counts no. of eligible M/F for ART given current CD4 elig criteria. */
    
    long NNotOnArt_m_cd4[NCD4];
    long NNotOnArt_f_cd4[NCD4];
    
    long NOnArt_m_cd4[NCD4];
    long NOnArt_f_cd4[NCD4];
    
    /* Reset counts (of those HIV positive stratified by CD4 category) to zero */
    for(i = 0; i < NCD4; i++){
        npositive_m_cd4[i] = 0;
        npositive_f_cd4[i] = 0;
        
        NNotOnArt_m_cd4[i] = 0;
        NNotOnArt_f_cd4[i] = 0;
        
        NOnArt_m_cd4[i] = 0;
        NOnArt_f_cd4[i] = 0;
    }
    
    int current_cd4_guidelines = art_cd4_eligibility_group(patch[p].param,(double) year);

    double prop_annual_acute;
    double prophivposonart;

    /* Temporary store of data from current year. */
    char temp_string[10000];
    
    int MINAGE_COUNTED = 0;
    int MAX_AGE_COUNTED = MAX_AGE - AGE_ADULT;
    
    for(g = 0; g < N_GENDER; g++){
        for(aa = MINAGE_COUNTED; aa < MAX_AGE_COUNTED; aa++){
            ai = aa + patch[p].age_list->age_list_by_gender[g]->youngest_age_group_index;
            while (ai>(MAX_AGE-AGE_ADULT-1)){
                ai = ai - (MAX_AGE-AGE_ADULT);
            }
            npop_check += patch[p].age_list->age_list_by_gender[g]->number_per_age_group[ai];
        }
        npop_check += patch[p].age_list->age_list_by_gender[g]->number_oldest_age_group;
    }

    for(g = 0; g < N_GENDER; g++){
        for(r = 0; r < N_RISK; r++){
            for(aa = MINAGE_COUNTED; aa < MAX_AGE_COUNTED; aa++){
                ai = aa + patch[p].n_infected->youngest_age_group_index;
                while(ai > (MAX_AGE - AGE_ADULT - 1)){
                    ai = ai - (MAX_AGE - AGE_ADULT);
                }
                
                /* NOTE: if we are getting prevalence by age group we have to offset the aa by
                n_infected->youngest_age_group_index. */
                npositive_wrong += patch[p].n_infected->pop_size_per_gender_age1_risk[g][ai][r];

                ai = aa + patch[p].n_newly_infected->youngest_age_group_index;
                while (ai > (MAX_AGE - AGE_ADULT - 1)){
                    ai = ai - (MAX_AGE - AGE_ADULT);
                }
                nincident += patch[p].n_newly_infected->pop_size_per_gender_age1_risk[g][ai][r];
            }
            npositive_wrong += patch[p].n_infected->pop_size_oldest_age_group_gender_risk[g][r];
            nincident += patch[p].n_newly_infected->pop_size_oldest_age_group_gender_risk[g][r];
        }
    }
    
    /* This if statement determines if we are just looking at PC stuff: */
    for (n_id = 0; n_id < patch[p].id_counter; n_id++){
        
        /* Check that the person is not dead: */
        if (patch[p].individual_population[n_id].cd4 != DEAD){
            
            /* Gender-specific outputs derived here: */
            if (patch[p].individual_population[n_id].gender == MALE){
                /* Use a function here so easy to add extra stratifications to output: */
                update_annual_outputs_gender_cd4(&(patch[p].individual_population[n_id]), &npop_m,
                    &npositive_m, &NNeedART_m, &NArt_m, npositive_m_cd4, NNotOnArt_m_cd4, 
                    NOnArt_m_cd4, current_cd4_guidelines);
            }else{ /* Else female */
                update_annual_outputs_gender_cd4(&(patch[p].individual_population[n_id]), &npop_f,
                    &npositive_f, &NNeedART_f, &NArt_f, npositive_f_cd4, NNotOnArt_f_cd4,
                    NOnArt_f_cd4, current_cd4_guidelines);
            }
        }else{
            n_dead += 1;
            if (patch[p].individual_population[n_id].HIV_status > 0){
                npositive_dead += 1;
            }
        }
    }
    npop = npop_m + npop_f;
    npositive = npositive_m + npositive_f;
    
    /* Store number of positive people in n_infected_total: */
    *n_infected_total = npositive;

    if (patch[p].PANGEA_N_ANNUALINFECTIONS > 0){
        
        prop_annual_acute = patch[p].PANGEA_N_ANNUALACUTEINFECTIONS/
            (1.0*patch[p].PANGEA_N_ANNUALINFECTIONS);
        
    }else{
        prop_annual_acute = 0.0;
    }
    
    if (npositive > 0){
        prophivposonart = (NArt_m + NArt_f)/(1.0*npositive);
    }else{
        prophivposonart = 0.0;
    }
    
    sprintf(temp_string,
        "%d,%d,%i,%8.6f,%8.6f,\
        %li,%li,%li,%li,%li,\
        %li,%li,%li,%li,%li,\
        %li,%li,%li,%li,%li,\
        %li,%li,%li,%li,%li,",
        i_run,
        patch[p].community_id,
        year,
        npositive/(npop+0.0),
        patch[p].PANGEA_N_ANNUALINFECTIONS/(npop - npositive + 0.0),
        npositive,
        patch[p].PANGEA_N_ANNUALINFECTIONS,
        npop,
        npositive_m,
        npop_m,
        npositive_f,
        npop_f,
        patch[p].calendar_outputs->N_calendar_HIV_tests_nonpopart[year_idx],
        patch[p].calendar_outputs->N_calendar_HIV_tests_popart[year_idx],
        patch[p].calendar_outputs->N_calendar_HIV_tests_popart_positive[year_idx],
        patch[p].calendar_outputs->N_calendar_HIV_tests_popart_negative[year_idx],
        patch[p].calendar_outputs->N_calendar_CD4_tests_nonpopart[year_idx],
        patch[p].calendar_outputs->N_calendar_CD4_tests_popart[year_idx],
        patch[p].calendar_outputs->N_calendar_CHIPS_visits[year_idx],
        NArt_m,
        NArt_f,
        patch[p].calendar_outputs->N_calendar_started_ART_annual[year_idx],
        patch[p].calendar_outputs->N_calendar_VMMC[year_idx],
        patch[p].calendar_outputs->N_calendar_dropout[year_idx],
        patch[p].OUTPUT_NDIEDFROMHIV);
    
    for(i = 0; i < (N_AGE_UNPD + 1); i++){
        sprintf(temp_string + strlen(temp_string), "%li,", patch[p].n_died_from_HIV[MALE][i]);
    }
    
    for(i = 0; i < (N_AGE_UNPD + 1); i++){
        sprintf(temp_string + strlen(temp_string), "%li,", patch[p].n_died_from_HIV[FEMALE][i]);
    }
    
    // Add number of person-years of mortality stratified by age and sex
    // "Mortality person-years" is a sum of (1 - "fraction of year after DoD").  
    for(i = 0; i < (N_AGE_UNPD + 1); i++){
        sprintf(temp_string + strlen(temp_string), "%8.6f,", patch[p].py_died_from_HIV[MALE][i]);
    }
    
    for(i = 0; i < (N_AGE_UNPD + 1); i++){
        sprintf(temp_string + strlen(temp_string), "%8.6f,", patch[p].py_died_from_HIV[FEMALE][i]);
    }
    
    /* Add to the end of the variable temp_string */
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%li,", npositive_m_cd4[i]);
    }
    
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%li,", npositive_f_cd4[i]);
    }
    
    
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%li,", NNotOnArt_m_cd4[i]);
    }
    
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%li,", NNotOnArt_f_cd4[i]);
    }
    
    
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%li,", NOnArt_m_cd4[i]);
    }
    
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%li,", NOnArt_f_cd4[i]);
    }
    
    // Units in terms of person-years.  Those positive on ART.  
    for(i = 0; i < NCD4; i++){
        sprintf(temp_string + strlen(temp_string), "%f,", patch[p].py_n_positive_on_art[i]);
    }
    
    // Units in terms of person-years.  Those positive not on ART.  
    for(i = 0; i < (NCD4 - 1); i++){
        sprintf(temp_string + strlen(temp_string), "%f,", patch[p].py_n_positive_not_on_art[i]);
    }
    
    sprintf(temp_string + strlen(temp_string), "%f", patch[p].py_n_positive_not_on_art[NCD4-1]);
    
    strcat(temp_string, "\n");
    
    /* Add the string `temp_string` to the `output` structure (so as to be written to file)*/
    join_strings_with_check(output->cost_effectiveness_outputs_string[p], 
        temp_string, SIZEOF_cost_effectiveness_outputs_string, 
        "output->annual_outputs_string[p] and temp_string in store_annual_outputs()");
}


void write_cost_effectiveness_outputs(file_struct *file_data_store, output_struct *output, int p){
    /* Write cost_effectiveness_outputs_string (an attribute of an output_struct) into a file.  
    
    Arguments
    ---------
    file_data_store : pointer to a file_struct structure
        Structure with information on filenames to be used for writing.  
    output : pointer to a output_struct structure
        Output structure where the strings to be written to file are stored.  
    p : int
        Patch of interest
    
    Returns
    -------
    Nothing; strings are written to file.  
    */
    
    /* Open connection to the patch-specific file where annual outputs are to be written to file */
    file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p] =
        fopen(file_data_store->filename_cost_effectiveness_output[p], "w");
    
    if(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p] == NULL){
        printf("Cannot open cost_effectiveness_output file\n");
        fflush(stdout);
        exit(1);
    }
    
    /* Print the header of the file */
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "RunID,CommunityID,Year,Prevalence,Incidence,NumberPositive,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "NAnnual,TotalPopulation,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "NumberPositiveM,PopulationM,NumberPositiveF,PopulationF,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "AnnualNonPopartHIVtests,AnnualPopartHIVtests,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "AnnualPopartHIVtests_positive,AnnualPopartHIVtests_negative,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "AnnualNonPopartCD4tests,AnnualPopartCD4tests,AnnualCHIPSvisits,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "NOnARTM,NOnARTF,AnnualInitiatingART,");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "AnnualVMMC,AnnualDropout,NDied_from_HIV,");
    
    int i;
    for(i = 0; i < N_AGE_UNPD; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NDied_from_HIVM%d_%d,", AGE_GROUPS_UNPD[i], AGE_GROUPS_UNPD[i+1] - 1);
    }
    // Add a column for greater than 80
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "NDied_from_HIVM%d_over,", AGE_GROUPS_UNPD[N_AGE_UNPD]);
    
    for(i = 0; i < N_AGE_UNPD; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NDied_from_HIVF%d_%d,", AGE_GROUPS_UNPD[i], AGE_GROUPS_UNPD[i+1] - 1);
    }
    // Add a column for greater than 80
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "NDied_from_HIVF%d_over,", AGE_GROUPS_UNPD[N_AGE_UNPD]);
    
    for(i = 0; i < N_AGE_UNPD; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "PYDied_from_HIVM%d_%d,", AGE_GROUPS_UNPD[i], AGE_GROUPS_UNPD[i+1] - 1);
    }
    // Add a column for greater than 80
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "PYDied_from_HIVM%d_over,", AGE_GROUPS_UNPD[N_AGE_UNPD]);
    
    for(i = 0; i < N_AGE_UNPD; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "PYDied_from_HIVF%d_%d,", AGE_GROUPS_UNPD[i], AGE_GROUPS_UNPD[i+1] - 1);
    }
    // Add a column for greater than 80
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "PYDied_from_HIVF%d_over,", AGE_GROUPS_UNPD[N_AGE_UNPD]);
    
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NumberPositiveM_CD4_%d,", i + 1);
    }
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NumberPositiveF_CD4_%d,", i + 1);
    }
    
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NumberPositiveNotOnARTM_CD4_%d,", i + 1);
    }
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NumberPositiveNotOnARTF_CD4_%d,", i + 1);
    }
    
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NumberPositiveOnARTM_CD4_%d,", i + 1);
    }
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "NumberPositiveOnARTF_CD4_%d,", i + 1);
    }
    
    for(i = 0; i < NCD4; i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "PYNumberPositiveOnART_CD4_%d,", i + 1);
    }
    
    for(i = 0; i < (NCD4-1); i++){
        fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
            "PYNumberPositiveNotOnART_CD4_%d,", i + 1);
    }
    
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p],
        "PYNumberPositiveNotOnART_CD4_%d", NCD4);
    
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p], "\n");
    fprintf(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p], "%s\n",
        output->cost_effectiveness_outputs_string[p]);
    fclose(file_data_store->COST_EFFECTIVENESS_OUTPUT_FILE[p]);
}


void update_annual_outputs_gender_cd4(individual *individual, long *npop_g, long *npositive, 
    long *NNeedART, long *NArt, long npositive_cd4[NCD4], long NNotOnArt[NCD4], 
    long NOnArt[NCD4], int current_cd4_guidelines){
    /* Update counters of total number of HIV+, on ART, for a given individual.  
    
    
    The counters are typically gender-specific and this function is called from the function
    store_annual_outputs() to avoid repetition.  
    
    Arguments
    ---------
    individual : pointer to an individual structure
        The individual in question who needs their status counted.  
    npop_g : pointer to a long
        Current count of population size.  
    npositive : pointer to a long
        Current count of individuals who are HIV positive.  
    NNeedART : pointer to a long
        Current counter of individuals who are eligible for ART.  
    NArt : pointer to a long
        Current count of individuals on ART.  
    current_cd4_guidelines : int
        The highest CD4 category that is eligible for ART.  See function art_cd4_eligibility_group()
        within hiv.c for details of how this variable is generated.  
    
    Returns
    -------
    Nothing; the input arguments npop_g, npositive, NNeedART, NArt are updated.  
    
    */
    
    *npop_g += 1;
    
    if(individual->HIV_status > UNINFECTED){
        
        (*npositive) += 1;
        npositive_cd4[individual->cd4] += 1;
        
        if(individual->cd4 >= current_cd4_guidelines){
            (*NNeedART) += 1;
        }
        
        if(
        (individual->ART_status == EARLYART) || 
        (individual->ART_status == LTART_VS) || 
        (individual->ART_status == LTART_VU)
        ){
            (*NArt) += 1;
            NOnArt[individual->cd4] += 1;
        }else{
            // Increment CD4 number of positives stratified by CD4 category.
            // This gives the number of people who are on ART by CD4 category.
            //= 0 if positive but not yet on ART (or dropped out)
            NNotOnArt[individual->cd4] += 1;
        }
    }
}


void store_treats_outputs(patch_struct *patch, int p, output_struct *output, 
    all_partnerships *overall_partnerships, int *n_infected_total, int year, int i_run){
    
    int aa, gg, icd4, ispvl, iart;
    int age, ai, gi, cd4, spvl, art; 
    long n_id;
    long npop[N_GENDER][N_AGE_UNPD + 1][NCD4+1][NSPVL+1][NARTEVENTS - 1];
    char temp_string[10000];
    
    // Set counters of total population and HIV positive population to 0
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                for(icd4 = 0; icd4 < NCD4+1; icd4++){
                    for(iart = 0; iart < NARTEVENTS - 1; iart++){
                        npop[gg][aa][icd4][ispvl][iart] = 0;
                    }
                }
            }
        }
    }
    
    // Age/sex/VL/CD4 category/ART status
    for(n_id = 0; n_id < patch[p].id_counter; n_id++){
        /* Check that the person is not dead: */
        if(patch[p].individual_population[n_id].cd4 != DEAD){
            
            // Find sex
            gi = patch[p].individual_population[n_id].gender;
            
            // Find age and convert to index
            age = (int) floor(year - patch[p].individual_population[n_id].DoB);
            if(age >= MAX_AGE){
                age = MAX_AGE;
            }
            ai = FIND_AGE_GROUPS_UNPD[age - AGE_ADULT];
            
            cd4 = patch[p].individual_population[n_id].cd4;
            spvl = patch[p].individual_population[n_id].SPVL_cat;
            art = patch[p].individual_population[n_id].ART_status;
            
            // For uninfected individuals (SPVL_cat == -1), make sure indexing is correct
            spvl += 1;
            if(spvl < 0){
                printf("Error, SPVL_cat < 0\n");
                fflush(stdout);
                exit(1);
            }
            
            // HIV uninfected inidividuals (CD4 == -1) have index of 0.  
            cd4 += 1;
            if(cd4 < 0){
                printf("Error, cd4 category < 0\n");
                fflush(stdout);
                exit(1);
            }
            
            if(art == ARTNAIVE || art == ARTNEG){
                art = 0;
            }else if(art == EARLYART){
                art = EARLYART;
            }else if(art == LTART_VS){
                art = LTART_VS;
            }else if(art == LTART_VU){
                art = LTART_VU;
            }else if(art == ARTDROPOUT){
                art = ARTDROPOUT;
            }else if(art == CASCADEDROPOUT){
                art = CASCADEDROPOUT;
            }else if(art == ARTDEATH){
                art = ARTDEATH;
            }else{
                printf("Unknown ART status\n");
                exit(1);
            }
            
            npop[gi][ai][cd4][spvl][art] += 1;
        }
    }
    
    // Store the outputs of RunID,CommunityID,Year
    sprintf(temp_string, "%d,%d,%d,", i_run, patch[p].community_id, year);
    join_strings_with_check(output->treats_outputs_string[p], temp_string,  
        SIZEOF_calibration_outputs - 1, 
        "treats_outputs_string and temp_string in store_treats_outputs()");
    
    // Store total population
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    for(iart = 0; iart < NARTEVENTS - 1; iart++){
                        
                        sprintf(temp_string, "%ld,",
                            npop[gg][aa][icd4][ispvl][iart]);
                        
                        join_strings_with_check(output->treats_outputs_string[p], temp_string,  
                            SIZEOF_calibration_outputs - 1, 
                            "treats_outputs_string and temp_string in store_treats_outputs()");
                    }
                }
            }
        }
    }
    
    // Write incident infections to file
    int year_idx = (int) floor(year - patch[p].param->start_time_simul) - 1;
    
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            sprintf(temp_string, "%li,",
                patch[p].calendar_outputs->N_calendar_infections[gg][aa][year_idx]);
            join_strings_with_check(output->treats_outputs_string[p], temp_string,  
                SIZEOF_calibration_outputs - 1, 
                "treats_outputs_string and temp_string in store_treats_outputs()");
        }
    }
    
    // Write ART initiations to file.  
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    sprintf(temp_string, "%li,",
                        patch[p].calendar_outputs->N_calendar_started_ART[gg][aa][icd4][ispvl][year_idx]);
                    
                    join_strings_with_check(output->treats_outputs_string[p], temp_string,  
                        SIZEOF_calibration_outputs - 1, 
                        "treats_outputs_string and temp_string in store_treats_outputs()");
                }
            }
        }
    }
    
    // Write HIV-related deaths to file (among those on ART)
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    
                    sprintf(temp_string, "%li,",
                        patch[p].calendar_outputs->N_calendar_Died_from_HIV_ARTNaive[gg][aa][icd4][ispvl][year_idx]);
                    
                    join_strings_with_check(output->treats_outputs_string[p], 
                        temp_string, SIZEOF_calibration_outputs - 1, 
                        "treats_outputs_string and temp_string in store_treats_outputs()");
                }
            }
        }
    }
    
    // Write HIV-related deaths to file (among ART naive)
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    
                    sprintf(temp_string, "%li,",
                        patch[p].calendar_outputs->N_calendar_Died_from_HIV_OnART[gg][aa][icd4][ispvl][year_idx]);
                    
                    join_strings_with_check(output->treats_outputs_string[p], 
                        temp_string, SIZEOF_calibration_outputs - 1, 
                        "treats_outputs_string and temp_string in store_treats_outputs()");
                }
            }
        }
    }

    // Write annual dropouts to file (among those on ART)
    for(gg = 0; gg < N_GENDER; gg++){
        for(aa = 0; aa < N_AGE_UNPD + 1; aa++){
            for(icd4 = 0; icd4 < NCD4 + 1; icd4++){
                for(ispvl = 0; ispvl < NSPVL + 1; ispvl++){
                    
                    // Do not include a comma on the last entry
                    if(
                    (aa == N_AGE_UNPD) &&
                    (gg == N_GENDER-1) &&
                    (ispvl == NSPVL) &&
                    (icd4 == NCD4)){
                        sprintf(temp_string, "%li",
                            patch[p].calendar_outputs->N_calendar_AnnualDropoutOnART[gg][aa][icd4][ispvl][year_idx]);
                    }else{
                        sprintf(temp_string, "%li,",
                            patch[p].calendar_outputs->N_calendar_AnnualDropoutOnART[gg][aa][icd4][ispvl][year_idx]);
                    }
                    
                    join_strings_with_check(output->treats_outputs_string[p], 
                        temp_string, SIZEOF_calibration_outputs - 1, 
                        "treats_outputs_string and temp_string in store_treats_outputs()");
                }
            }
        }
    }
    
    strcat(output->treats_outputs_string[p], "\n");
}


void write_treats_outputs(file_struct *file_data_store, output_struct *output, int p){
    /* Write treats_outputs_string (an attribute of an output_struct) into a file.  
    
    Arguments
    ---------
    file_data_store : pointer to a file_struct structure
        Structure with information on filenames to be used for writing.  
    output : pointer to a output_struct structure
        Output structure where the strings to be written to file are stored.  
    p : int
        Patch of interest
    
    Returns
    -------
    Nothing; strings are written to file.  
    */
    
    /* Open connection to the patch-specific file where annual outputs are to be written to file */
    file_data_store->TREATS_OUTPUT_FILE[p] =
        fopen(file_data_store->filename_treats_output[p], "w");
    
    if(file_data_store->TREATS_OUTPUT_FILE[p] == NULL){
        printf("Cannot open treats_output file\n");
        fflush(stdout);
        exit(1);
    }
    
    /* Print the header of the file */
    fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
        "RunID,CommunityID,Year,");
    
    int a, g, icd4, ispvl, iart;
    char *g_text;
    
    // population size at each week by age/sex/VL/CD4 category/ART status.  5 year age groups.  
    for(g = 0; g < N_GENDER; g++){ // sex
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }
        
        for(a = 0; a < N_AGE_UNPD + 1; a++){ // age
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    for(iart = 0; iart < NARTEVENTS - 1; iart++){
                        
                        if(a == N_AGE_UNPD){
                            fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                                "Ntot_%s_%d_over_CD4%d_SPVL%d_ART%d,", g_text, 
                                    AGE_GROUPS_UNPD[a], icd4, ispvl, iart);
                        }else{
                            fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                                "Ntot_%s_%d_%d_CD4%d_SPVL%d_ART%d,", g_text, 
                                    AGE_GROUPS_UNPD[a], AGE_GROUPS_UNPD[a+1] - 1, 
                                    icd4, ispvl, iart);
                        }
                    }
                }
            }
        }
    }
    
    // Count HIV positive population at each week: age/sex.  5 year age groups.  
    for(g = 0; g < N_GENDER; g++){ // sex
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }
        
        for(a = 0; a < N_AGE_UNPD + 1; a++){ // age
            if(a == N_AGE_UNPD){
                fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                    "Ninc_%s_%d_over,", g_text, AGE_GROUPS_UNPD[a]);
            }else{
                fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                    "Ninc_%s_%d_%d,", g_text, AGE_GROUPS_UNPD[a], AGE_GROUPS_UNPD[a+1] - 1);
            }
        }
    }
    
    // ART intiations
    for(g = 0; g < N_GENDER; g++){ // sex
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }
        
        for(a = 0; a < N_AGE_UNPD + 1; a++){ // age
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    if(a == N_AGE_UNPD){
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "NARTinit_%s_%d_over_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], icd4, ispvl);
                    }else{
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "NARTinit_%s_%d_%d_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], AGE_GROUPS_UNPD[a+1] - 1, 
                                icd4, ispvl);
                    }
                }
            }
        }
    }
    
    // HIV-related deaths among HIV positive among those that are ART naive
    for(g = 0; g < N_GENDER; g++){ // sex
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }
        
        for(a = 0; a < N_AGE_UNPD + 1; a++){ // age
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    if(a == N_AGE_UNPD){
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "NDied_from_HIV_ARTNaive_%s_%d_over_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], icd4, ispvl);
                    }else{
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "NDied_from_HIV_ARTNaive_%s_%d_%d_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], AGE_GROUPS_UNPD[a+1] - 1, 
                                icd4, ispvl);
                    }
                }
            }
        }
    }

    // HIV-related deaths among HIV positive among those receiving ART
    for(g = 0; g < N_GENDER; g++){ // sex
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }
        
        for(a = 0; a < N_AGE_UNPD + 1; a++){ // age
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    if(a == N_AGE_UNPD){
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "NDied_from_HIV_OnART_%s_%d_over_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], icd4, ispvl);
                    }else{
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "NDied_from_HIV_OnART_%s_%d_%d_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], AGE_GROUPS_UNPD[a+1] - 1, 
                                icd4, ispvl);
                    }
                }
            }
        }
    }

    // Drop-outs and LTFU among those receiving ART
    for(g = 0; g < N_GENDER; g++){ // sex
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }

        for(a = 0; a < N_AGE_UNPD + 1; a++){ // age
            for(icd4 = 0; icd4 < NCD4+1; icd4++){
                for(ispvl = 0; ispvl < NSPVL+1; ispvl++){
                    if(a == N_AGE_UNPD){
                        if(
                        (a == N_AGE_UNPD) && 
                        (g == N_GENDER-1) && 
                        (ispvl == NSPVL) && 
                        (icd4 == NCD4)){
                            fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                                "AnnualDropoutOnART_%s_%d_over_CD4%d_SPVL%d", g_text, 
                                    AGE_GROUPS_UNPD[a], icd4, ispvl);
                        }else{
                            fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                                "AnnualDropoutOnART_%s_%d_over_CD4%d_SPVL%d,", g_text, 
                                    AGE_GROUPS_UNPD[a], icd4, ispvl);
                        }
                    }else{
                        fprintf(file_data_store->TREATS_OUTPUT_FILE[p],
                            "AnnualDropoutOnART_%s_%d_%d_CD4%d_SPVL%d,", g_text, 
                                AGE_GROUPS_UNPD[a], AGE_GROUPS_UNPD[a+1] - 1, 
                                icd4, ispvl);
                    }
                }
            }
        }
    }

    fprintf(file_data_store->TREATS_OUTPUT_FILE[p], "\n");
    fprintf(file_data_store->TREATS_OUTPUT_FILE[p], "%s",
        output->treats_outputs_string[p]);
    fclose(file_data_store->TREATS_OUTPUT_FILE[p]);
}


void store_art_status_by_age_sex(patch_struct *patch, int p, double t, output_struct *output){
    /*
    
    Parameters
    ----------
    patch : pointer to a patch_struct
    p : int
    t : double
    output : pointer to a output_struct object
    */

    int g, a, age, ihiv, iart;
    long n_id;
    long npop[N_GENDER][MAX_AGE - AGE_ADULT + 1][3][NARTEVENTS];
    
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < (MAX_AGE - AGE_ADULT + 1); a++){
            for(ihiv = 0; ihiv < 3; ihiv++){
                for(iart = 0; iart < NARTEVENTS; iart++){
                    npop[g][a][ihiv][iart] = 0;
                }
            }
        }
    }
    
    char temp_string[10000]; // Temporary store of data from current year.

    for(n_id = 0; n_id < patch[p].id_counter; n_id++){
        /* Check that the person is not dead: */
        if(patch[p].individual_population[n_id].cd4 != DEAD){
            
            
            // Find gender, sex, and ART status
            g = patch[p].individual_population[n_id].gender;
            
            age = floor(t - patch[p].individual_population[n_id].DoB);
            
            if(age > MAX_AGE){
                age = MAX_AGE;
            }
            a = age - AGE_ADULT;
            
            ihiv = patch[p].individual_population[n_id].HIV_status;
            iart = patch[p].individual_population[n_id].ART_status + 1;
            
            if(ihiv < UNINFECTED || ihiv > CHRONIC){
                printf("Error: Unknown HIV status; exiting\n");
                fflush(stdout);
                exit(1);
            }
            
            npop[g][a][ihiv][iart] += 1;
        }
    }
    
    // Store the outputs of time
    sprintf(temp_string, "%6.4f,", t);
    
    join_strings_with_check(output->art_status_by_age_sex_outputs_string[p], 
        temp_string, 
        N_TIME_STEP_PER_YEAR/OUTPUTTIMESTEP*SIZEOF_calibration_outputs - 1, 
        "art_status_by_age_sex_outputs_string and temp_string in store_art_status_...()");
    
    for(g = 0; g < N_GENDER; g++){
        for(a = 0; a < MAX_AGE - AGE_ADULT + 1; a++){
            for(ihiv = 0; ihiv < 3; ihiv++){
                for(iart = 0; iart < NARTEVENTS; iart++){
                
                    if(g == (N_GENDER - 1) && a == (MAX_AGE - AGE_ADULT) && 
                        ihiv == 2 && iart == NARTEVENTS - 1){
                        sprintf(temp_string, "%li", npop[g][a][ihiv][iart]);
                
                        join_strings_with_check(output->art_status_by_age_sex_outputs_string[p],
                            temp_string,
                            N_TIME_STEP_PER_YEAR/OUTPUTTIMESTEP*SIZEOF_calibration_outputs - 1, 
                            "art_status_..._string and temp_string in store_art_status...()");
                    }else{
                        sprintf(temp_string, "%li,", npop[g][a][ihiv][iart]);
                
                        join_strings_with_check(output->art_status_by_age_sex_outputs_string[p],
                            temp_string, 
                            N_TIME_STEP_PER_YEAR/OUTPUTTIMESTEP*SIZEOF_calibration_outputs - 1, 
                            "art_status_..._string and temp_string in store_art_status...()");
                    }
                }
            }
        }
    }
    
    // Add a newline to the output string
    strcat(output->art_status_by_age_sex_outputs_string[p], "\n");
}


void write_art_status_by_age_sex(file_struct *file_data_store, output_struct *output, int p){
    /*
    Writes out the timestep_outputs_string into a file
    the timestep_outputs_string is populated using the function store_timestep_outputs()
    
    Parameters
    ----------
    file_data_store : pointer to file_struct
        Assumes that `file_data_store` has an attribute `filename_timestep_output` and 
        `filename_timestep_output_PConly`
    output : pointer to output_struct
        
    p : int 
        Patch number
    */
    
    /* Write to correct file: */
    file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p] = 
        fopen(file_data_store->filename_art_status_by_age_sex_output[p],"w");
    
    if (file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p] == NULL){
        printf("Cannot open ART_status_by_age_sex file\n");
        printf("LINE %d; FILE %s\n", __LINE__, __FILE__);
        fflush(stdout);
        exit(1);
    }
    
    // Write the header line
    fprintf(file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p],"Time,");
    
    int g, a, ihiv, iart;
    char *g_text;
    
    for(g = 0; g < N_GENDER; g++){
        
        if(g == MALE){
            g_text = "M";
        }else{
            g_text = "F";
        }
        
        for(a = AGE_ADULT; a <= MAX_AGE; a++){
            for(ihiv = 0; ihiv < 3; ihiv++){
                for(iart = ARTNEG; iart <= ARTDEATH; iart++){
                    if(g == (N_GENDER - 1) && a == MAX_AGE && ihiv == 2 && iart == ARTDEATH){
                        fprintf(file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p],
                            "N%s%d_HIV%d_ART%d\n", g_text, a, ihiv, iart);
                    }else{
                        fprintf(file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p],
                            "N%s%d_HIV%d_ART%d,", g_text, a, ihiv, iart);
                    }
                }
            }
        }
    }
    
    fprintf(file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p],
        "%s\n", output->art_status_by_age_sex_outputs_string[p]);
    
    // Close the connection to the file
    fclose(file_data_store->ART_STATUS_BY_AGE_SEX_OUTPUT_FILE[p]);
}